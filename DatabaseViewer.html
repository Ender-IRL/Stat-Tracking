<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Basketball Database Viewer</title>
  <style>
    :root {
      --bg: #f7f6f2;
      --panel: #ffffff;
      --ink: #0f172a;
      --muted: #6b7280;
      --accent: #0f172a;
      --accent-2: #e2e8f0;
      --good: #22c55e;
      --warn: #f97316;
      --bad: #ef4444;
      --stroke: #e5e7eb;
    }

    * {
      box-sizing: border-box;
    }

    .hidden {
      display: none;
    }

    body {
      margin: 0;
      font-family: "Georgia", "Times New Roman", serif;
      background: radial-gradient(circle at top, #ffffff 0%, #f3f4f6 35%, #ede9fe 100%);
      color: var(--ink);
    }

    header {
      padding: 24px 28px 12px;
    }

    h1 {
      margin: 0 0 6px 0;
      font-size: 28px;
      letter-spacing: 0.5px;
    }

    p {
      margin: 4px 0;
      color: var(--muted);
    }

    .upload-panel {
      margin: 16px 28px 0;
      background: var(--panel);
      border-radius: 16px;
      border: 1px solid var(--stroke);
      padding: 16px;
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.08);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .upload-row {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 12px;
    }

    input[type="file"] {
      padding: 8px;
      background: #f8fafc;
      border: 1px dashed var(--stroke);
      border-radius: 8px;
    }

    .tabs {
      margin: 18px 28px 0;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .tab-button {
      padding: 10px 16px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: #ffffff;
      cursor: pointer;
      font-weight: 700;
      color: var(--ink);
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.2s ease;
    }

    .tab-button.active {
      background: var(--accent);
      color: #ffffff;
      box-shadow: 0 12px 22px rgba(15, 23, 42, 0.22);
      transform: translateY(-1px);
    }

    main {
      padding: 16px 28px 40px;
    }

    .page {
      display: none;
      background: var(--panel);
      border-radius: 18px;
      border: 1px solid var(--stroke);
      padding: 20px;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.08);
      margin-bottom: 20px;
    }

    .page.active {
      display: block;
      animation: fadeIn 0.4s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .page-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 12px;
    }

    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 8px;
    }

    .section-header h3 {
      margin: 0;
    }

    .page-header h2 {
      margin: 0;
      font-size: 22px;
    }

    .filters {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--muted);
    }

    select {
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid var(--stroke);
      font-family: inherit;
    }

    .summary-grid {
      margin-top: 16px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
    }

    .summary-card {
      background: #f8fafc;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      padding: 12px;
      min-height: 82px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .summary-card .label {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.6px;
    }

    .summary-card .value {
      font-size: 20px;
      font-weight: 700;
      color: var(--ink);
    }

    .chart-section {
      margin-top: 20px;
    }

    .shot-chart-wrapper {
      background: linear-gradient(180deg, #f8fafc 0%, #e2e8f0 100%);
      border: 1px solid var(--stroke);
      border-radius: 16px;
      padding: 12px;
    }

    .shot-chart-grid {
      position: relative;
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      grid-template-rows: repeat(4, auto);
      gap: 16px;
      max-width: 820px;
      margin: 0 auto;
      padding: 12px 12px 28px 12px;
    }

    .shot-chart-grid::before {
      content: '';
      position: absolute;
      top: 6px;
      left: 50%;
      transform: translateX(-50%) rotate(180deg);
      width: 560px;
      height: 280px;
      background-color: #f5deb3;
      border-top-left-radius: 280px;
      border-top-right-radius: 280px;
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      border: 4px solid #111827;
      z-index: 0;
    }

    .chart-zone {
      position: relative;
      z-index: 1;
      background: #e2e8f0;
      border: 1px solid #cbd5e1;
      border-radius: 12px;
      min-height: 88px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.8);
      transition: background-color 0.25s ease;
    }

    .chart-zone .zone-name {
      font-weight: 700;
      font-size: 13px;
      text-align: center;
    }

    .chart-zone .zone-metrics {
      font-size: 12px;
      margin-top: 6px;
      color: #0f172a;
    }

    .chart-zone.selected {
      outline: 3px solid #0f172a;
      outline-offset: 2px;
    }

    .chart-zone.left-corner { grid-area: 1 / 1; }
    .chart-zone.short-left { grid-area: 1 / 2; }
    .chart-zone.at-rim { grid-area: 1 / 3; }
    .chart-zone.short-right { grid-area: 1 / 4; }
    .chart-zone.right-corner { grid-area: 1 / 5; }
    .chart-zone.left-mid { grid-area: 2 / 2; }
    .chart-zone.center-mid { grid-area: 2 / 3; }
    .chart-zone.right-mid { grid-area: 2 / 4; }
    .chart-zone.left-wing { grid-area: 3 / 1; }
    .chart-zone.center-arc { grid-area: 4 / 3; }
    .chart-zone.right-wing { grid-area: 3 / 5; }

    .game-log {
      margin-top: 20px;
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      min-width: 720px;
    }

    th, td {
      padding: 8px 6px;
      border: 1px solid var(--stroke);
      text-align: center;
    }

    th {
      background: var(--accent);
      color: #ffffff;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.4px;
    }

    td:first-child, th:first-child {
      text-align: left;
      font-weight: 700;
    }

    tfoot td {
      font-weight: 700;
      background: #f8fafc;
    }

    tfoot tr.averages-row td {
      background: #eef2ff;
    }

    .legend {
      margin-top: 8px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      font-size: 12px;
      color: var(--muted);
    }

    .legend span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .legend i {
      width: 14px;
      height: 10px;
      border-radius: 4px;
      border: 1px solid #cbd5e1;
      display: inline-block;
    }

    .legend .cold { background: #f87171; }
    .legend .neutral { background: #fbbf24; }
    .legend .hot { background: #34d399; }

    .zone-breakdown {
      margin-top: 14px;
      border: 1px solid var(--stroke);
      border-radius: 12px;
      background: #ffffff;
      padding: 12px;
    }

    .zone-breakdown h4 {
      margin: 0 0 8px 0;
      font-size: 14px;
    }

    .zone-breakdown table {
      min-width: 0;
      font-size: 12px;
    }

    .zone-breakdown td:first-child, .zone-breakdown th:first-child {
      text-align: left;
    }

    @media (max-width: 720px) {
      header, main {
        padding: 16px;
      }

      .upload-panel, .tabs {
        margin: 12px 16px 0;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Basketball Game Log Database</h1>
    <p>Upload a folder of CAMT.csv exports to summarize stats for the team and each player.</p>
  </header>

  <div class="upload-panel">
    <div class="upload-row">
      <input type="file" id="folderInput" webkitdirectory multiple />
      <span id="uploadStatus">No files loaded.</span>
    </div>
    <p>Roster locked to #1 Mike, #2 Stanley, #3 Ryan, #4 Jim, #5 Dwight. Player IDs are matched by name or the last two digits.</p>
  </div>

  <div class="tabs" id="pageTabs"></div>

  <main id="pages"></main>

  <script>
    const roster = [
      { number: 1, name: 'Mike' },
      { number: 2, name: 'Stanley' },
      { number: 3, name: 'Ryan' },
      { number: 4, name: 'Jim' },
      { number: 5, name: 'Dwight' }
    ];

    const zoneKeys = [
      'LeftCorner',
      'ShortLeft',
      'AtRim',
      'ShortRight',
      'RightCorner',
      'LeftMid',
      'CenterMid',
      'RightMid',
      'LeftWing',
      'CenterArc',
      'RightWing'
    ];

    const zoneLabels = {
      LeftCorner: 'Left Corner 3',
      ShortLeft: 'Short Left',
      AtRim: 'At Rim',
      ShortRight: 'Short Right',
      RightCorner: 'Right Corner 3',
      LeftMid: 'Left Mid',
      CenterMid: 'Center Mid',
      RightMid: 'Right Mid',
      LeftWing: 'Left Wing 3',
      CenterArc: 'Center Arc 3',
      RightWing: 'Right Wing 3'
    };

    const zoneColumnLabels = {
      LeftCorner: 'Left Corner',
      ShortLeft: 'Short Left',
      AtRim: 'At Rim',
      ShortRight: 'Short Right',
      RightCorner: 'Right Corner',
      LeftMid: 'Left Mid',
      CenterMid: 'Center Mid',
      RightMid: 'Right Mid',
      LeftWing: 'Left Wing',
      CenterArc: 'Center Arc',
      RightWing: 'Right Wing'
    };

    const zoneCategoryLookup = {
      LeftCorner: 'three',
      RightCorner: 'three',
      LeftWing: 'three',
      RightWing: 'three',
      CenterArc: 'three',
      AtRim: 'atRim',
      ShortLeft: 'midRange',
      ShortRight: 'midRange',
      LeftMid: 'midRange',
      CenterMid: 'midRange',
      RightMid: 'midRange'
    };

    const zoneAverages = {
      atRim: 0.6,
      midRange: 0.4,
      three: 0.3
    };

    const zoneRange = 0.2;
    const maxAttemptsForIntensity = 10;

    const state = {
      games: {},
      teamShotMode: 'totals',
      selectedTeamZone: null,
      overall: {
        team: createEmptyStats(),
        players: createRosterStats()
      }
    };

    const pageTabs = document.getElementById('pageTabs');
    const pagesContainer = document.getElementById('pages');

    initPages();

    document.getElementById('folderInput').addEventListener('change', async (event) => {
      const files = Array.from(event.target.files || []).filter(file => file.name.toLowerCase().endsWith('.csv'));
      if (!files.length) {
        document.getElementById('uploadStatus').textContent = 'No CSV files found in that folder.';
        return;
      }

      document.getElementById('uploadStatus').textContent = `Loading ${files.length} file(s)...`;
      resetState();

      const parsedFiles = await Promise.all(files.map(file => parseCsvFile(file)));
      parsedFiles.forEach((result) => {
        if (result) {
          state.games[result.key] = result.game;
        }
      });

      buildOverallTotals();
      renderAll();
      document.getElementById('uploadStatus').textContent = `Loaded ${Object.keys(state.games).length} game(s).`;
    });

    function initPages() {
      const pages = [{ key: 'team', label: 'Team' }].concat(
        roster.map(player => ({ key: String(player.number), label: `${player.name}` }))
      );

      pages.forEach((page, index) => {
        const button = document.createElement('button');
        button.className = `tab-button${index === 0 ? ' active' : ''}`;
        button.textContent = page.label;
        button.dataset.page = page.key;
        pageTabs.appendChild(button);

        const section = document.createElement('section');
        section.className = `page${index === 0 ? ' active' : ''}`;
        section.dataset.page = page.key;
        section.innerHTML = buildPageHtml(page);
        pagesContainer.appendChild(section);
      });

      pageTabs.addEventListener('click', (event) => {
        const target = event.target.closest('button[data-page]');
        if (!target) {
          return;
        }
        const pageKey = target.dataset.page;
        pageTabs.querySelectorAll('button').forEach(btn => btn.classList.toggle('active', btn === target));
        pagesContainer.querySelectorAll('.page').forEach(page => page.classList.toggle('active', page.dataset.page === pageKey));
      });
    }

    function buildPageHtml(page) {
      if (page.key === 'team') {
        return `
          <div class="page-header">
            <h2>Team Summary</h2>
            <div class="filters">
              <label>View</label>
              <select data-role="team-view">
                <option value="averages">Averages</option>
                <option value="totals">Totals</option>
                <option value="team-game">Team Game</option>
              </select>
            </div>
          </div>
          <div class="game-log">
            <div class="section-header">
              <h3 data-role="team-table-title">Player Averages</h3>
            </div>
            <table data-role="team-table">
              <thead></thead>
              <tbody></tbody>
              <tfoot></tfoot>
            </table>
          </div>
          <div class="chart-section">
            <div class="section-header">
              <h3>Shot Chart</h3>
              <div class="filters">
                <label>Game</label>
                <select data-role="shot-chart-select" data-page="team"></select>
                <span class="filters hidden" data-role="team-shot-mode-wrapper">
                  <label>Mode</label>
                  <select data-role="team-shot-mode">
                    <option value="totals">Totals</option>
                    <option value="averages">Averages</option>
                  </select>
                </span>
              </div>
            </div>
            <div class="shot-chart-wrapper">
              <div class="shot-chart-grid" data-role="shot-chart" data-page="team">
                ${zoneKeys.map(zone => `
                  <div class="chart-zone ${zoneToClass(zone)}" data-zone="${zone}">
                    <div class="zone-name">${zoneLabels[zone]}</div>
                    <div class="zone-metrics" data-zone-text="${zone}">0/0 (--%)</div>
                  </div>
                `).join('')}
              </div>
            </div>
            <div class="legend">
              <span><i class="cold"></i>Cold</span>
              <span><i class="neutral"></i>Average</span>
              <span><i class="hot"></i>Hot</span>
            </div>
            <div class="zone-breakdown" data-role="zone-breakdown">
              <h4 data-role="zone-breakdown-title">Click a zone to see player splits</h4>
              <table data-role="zone-breakdown-table">
                <thead>
                  <tr>
                    <th>Player</th>
                    <th>FG</th>
                    <th>FG%</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
          <div class="game-log">
            <div class="section-header">
              <h3>Game Box Score</h3>
              <div class="filters">
                <label>Game</label>
                <select data-role="team-box-select"></select>
              </div>
            </div>
            <table data-role="team-boxscore">
              <thead></thead>
              <tbody></tbody>
              <tfoot></tfoot>
            </table>
          </div>
          <div class="game-log">
            <div class="section-header">
              <h3>Game Log</h3>
            </div>
            <div class="zone-breakdown">
              <table data-role="team-action-log">
                <thead>
                  <tr>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
        `;
      }

      return `
        <div class="page-header">
          <h2>Player Summary: ${page.label}</h2>
        </div>
        <div class="game-log">
          <div class="section-header">
            <h3>Season Log</h3>
          </div>
          <table data-role="player-log" data-page="${page.key}">
            <thead></thead>
            <tbody></tbody>
            <tfoot></tfoot>
          </table>
        </div>
        <div class="chart-section">
          <div class="section-header">
            <h3>Shot Chart</h3>
            <div class="filters">
              <label>Game</label>
              <select data-role="shot-chart-select" data-page="${page.key}"></select>
              <span class="filters hidden" data-role="player-shot-mode-wrapper" data-page="${page.key}">
                <label>Mode</label>
                <select data-role="player-shot-mode" data-page="${page.key}">
                  <option value="totals">Totals</option>
                  <option value="averages">Averages</option>
                </select>
              </span>
            </div>
          </div>
          <div class="shot-chart-wrapper">
            <div class="shot-chart-grid" data-role="shot-chart" data-page="${page.key}">
              ${zoneKeys.map(zone => `
                <div class="chart-zone ${zoneToClass(zone)}" data-zone="${zone}">
                  <div class="zone-name">${zoneLabels[zone]}</div>
                  <div class="zone-metrics" data-zone-text="${zone}">0/0 (--%)</div>
                </div>
              `).join('')}
            </div>
          </div>
          <div class="legend">
            <span><i class="cold"></i>Cold</span>
            <span><i class="neutral"></i>Average</span>
            <span><i class="hot"></i>Hot</span>
          </div>
        </div>
      `;
    }

    function zoneToClass(zone) {
      return zone.replace(/[A-Z]/g, (match, offset) => (offset === 0 ? match.toLowerCase() : `-${match.toLowerCase()}`));
    }

    function createEmptyStats() {
      const zones = {};
      zoneKeys.forEach(zone => {
        zones[zone] = { make: 0, miss: 0 };
      });
      return {
        minutesSeconds: 0,
        offReb: 0,
        defReb: 0,
        ast: 0,
        potAst: 0,
        tov: 0,
        stl: 0,
        blk: 0,
        blkAgainst: 0,
        foulCommitted: 0,
        foulCalled: 0,
        ftMake: 0,
        ftMiss: 0,
        points: 0,
        zones
      };
    }

    function createRosterStats() {
      const players = {};
      roster.forEach(player => {
        players[player.number] = createEmptyStats();
      });
      return players;
    }

    function resetState() {
      state.games = {};
      state.teamShotMode = 'totals';
      state.selectedTeamZone = null;
      state.overall.team = createEmptyStats();
      state.overall.players = createRosterStats();
    }

    function addStats(target, source) {
      if (!source) {
        return;
      }
      target.minutesSeconds += source.minutesSeconds || 0;
      target.offReb += source.offReb || 0;
      target.defReb += source.defReb || 0;
      target.ast += source.ast || 0;
      target.potAst += source.potAst || 0;
      target.tov += source.tov || 0;
      target.stl += source.stl || 0;
      target.blk += source.blk || 0;
      target.blkAgainst += source.blkAgainst || 0;
      target.foulCommitted += source.foulCommitted || 0;
      target.foulCalled += source.foulCalled || 0;
      target.ftMake += source.ftMake || 0;
      target.ftMiss += source.ftMiss || 0;
      target.points += source.points || 0;

      zoneKeys.forEach(zone => {
        target.zones[zone].make += source.zones[zone].make || 0;
        target.zones[zone].miss += source.zones[zone].miss || 0;
      });
    }

    function buildOverallTotals() {
      Object.values(state.games).forEach(game => {
        addStats(state.overall.team, game.team);
        roster.forEach(player => {
          addStats(state.overall.players[player.number], game.players[player.number]);
        });
      });
    }

    async function parseCsvFile(file) {
      const text = await file.text();
      const rows = parseCsv(text);
      if (!rows.length) {
        return null;
      }

      const header = rows[0];
      const headerMap = {};
      header.forEach((value, index) => {
        headerMap[value.trim()] = index;
      });

      let gameId = '';
      let gameDate = '';
      const gamePlayers = createRosterStats();
      let teamStats = null;
      const actionLog = [];
      let inActionLog = false;

      for (let i = 1; i < rows.length; i++) {
        const row = rows[i];
        if (!row || row.length === 0) {
          continue;
        }
        if (row[0] && row[0].trim() === 'Action Log') {
          inActionLog = true;
          continue;
        }

        if (inActionLog) {
          const entry = String(row[0] || '').trim();
          if (entry) {
            actionLog.push(entry);
          }
          continue;
        }

        const playerName = getValue(row, headerMap, 'Player Name');
        const gameIdValue = getValue(row, headerMap, 'Game ID');
        const dateValue = getValue(row, headerMap, 'Date');

        if (!gameId && gameIdValue && gameIdValue !== 'N/A') {
          gameId = gameIdValue;
        }
        if (!gameDate && dateValue && dateValue !== 'N/A') {
          gameDate = dateValue;
        }

        if (playerName && playerName.toLowerCase() === 'team totals') {
          teamStats = parseStatsRow(row, headerMap);
          continue;
        }

        const playerNumber = matchRosterNumber(row, headerMap, playerName);
        if (!playerNumber) {
          continue;
        }

        addStats(gamePlayers[playerNumber], parseStatsRow(row, headerMap));
      }

      if (!teamStats) {
        teamStats = createEmptyStats();
        roster.forEach(player => {
          addStats(teamStats, gamePlayers[player.number]);
        });
      }

      const gameKey = file.name;
      const game = {
        key: gameKey,
        id: gameId || file.name.replace(/\.csv$/i, ''),
        date: gameDate || 'Unknown',
        team: teamStats,
        players: gamePlayers,
        actionLog
      };

      return { key: gameKey, game };
    }

    function parseStatsRow(row, headerMap) {
      const stats = createEmptyStats();
      stats.offReb = toNumber(getValue(row, headerMap, 'Offensive Rebound'));
      stats.defReb = toNumber(getValue(row, headerMap, 'Defensive Rebound'));
      stats.ast = toNumber(getValue(row, headerMap, 'Assist'));
      stats.potAst = toNumber(getValue(row, headerMap, 'Potential Assist'));
      stats.tov = toNumber(getValue(row, headerMap, 'Turnover'));
      stats.stl = toNumber(getValue(row, headerMap, 'Steal'));
      stats.blk = toNumber(getValue(row, headerMap, 'Block'));
      stats.blkAgainst = toNumber(getValue(row, headerMap, 'Block Against'));
      stats.foulCommitted = toNumber(getValue(row, headerMap, 'Foul Committed'));
      stats.foulCalled = toNumber(getValue(row, headerMap, 'Foul Called'));
      stats.ftMake = toNumber(getValue(row, headerMap, 'FT Make'));
      stats.ftMiss = toNumber(getValue(row, headerMap, 'FT Miss'));
      stats.minutesSeconds = parseTimeToSeconds(getValue(row, headerMap, 'Minutes'));
      stats.points = toNumber(getValue(row, headerMap, 'Points'));

      zoneKeys.forEach(zone => {
        const makeLabel = `${zoneColumnLabels[zone]} Makes`;
        const missLabel = `${zoneColumnLabels[zone]} Misses`;
        stats.zones[zone].make = toNumber(getValue(row, headerMap, makeLabel));
        stats.zones[zone].miss = toNumber(getValue(row, headerMap, missLabel));
      });

      return stats;
    }

    function matchRosterNumber(row, headerMap, playerName) {
      const normalizedName = String(playerName || '').trim().toLowerCase();
      const matchedByName = roster.find(player => player.name.toLowerCase() === normalizedName);
      if (matchedByName) {
        return matchedByName.number;
      }

      const playerId = String(getValue(row, headerMap, 'Player ID') || '').trim();
      const suffix = playerId.slice(-2);
      const number = parseInt(suffix, 10);
      if (roster.some(player => player.number === number)) {
        return number;
      }

      return null;
    }

    function getValue(row, headerMap, headerName) {
      const index = headerMap[headerName];
      if (index === undefined) {
        return '';
      }
      return row[index] || '';
    }

    function toNumber(value) {
      const num = parseInt(String(value || '0').trim(), 10);
      return Number.isFinite(num) ? num : 0;
    }

    function parseTimeToSeconds(value) {
      if (!value) {
        return 0;
      }
      const parts = String(value).trim().split(':').map(part => parseInt(part, 10));
      if (parts.some(part => Number.isNaN(part))) {
        return 0;
      }
      if (parts.length === 3) {
        return parts[0] * 3600 + parts[1] * 60 + parts[2];
      }
      if (parts.length === 2) {
        return parts[0] * 60 + parts[1];
      }
      return 0;
    }

    function formatDuration(seconds) {
      const total = Math.max(0, Math.round(seconds));
      const hrs = Math.floor(total / 3600);
      const mins = Math.floor((total % 3600) / 60);
      const secs = total % 60;
      if (hrs > 0) {
        return `${pad(hrs)}:${pad(mins)}:${pad(secs)}`;
      }
      return `${pad(mins)}:${pad(secs)}`;
    }

    function pad(value) {
      return String(value).padStart(2, '0');
    }

    function parseCsv(text) {
      const rows = [];
      let row = [];
      let current = '';
      let inQuotes = false;

      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        const next = text[i + 1];

        if (char === '"') {
          if (inQuotes && next === '"') {
            current += '"';
            i++;
          } else {
            inQuotes = !inQuotes;
          }
          continue;
        }

        if (char === ',' && !inQuotes) {
          row.push(current);
          current = '';
          continue;
        }

        if ((char === '\n' || char === '\r') && !inQuotes) {
          if (char === '\r' && next === '\n') {
            i++;
          }
          row.push(current);
          if (row.length && row.some(cell => cell !== '')) {
            rows.push(row);
          }
          row = [];
          current = '';
          continue;
        }

        current += char;
      }

      if (current || row.length) {
        row.push(current);
        if (row.length && row.some(cell => cell !== '')) {
          rows.push(row);
        }
      }

      return rows;
    }

    function buildDerived(stats) {
      const twoMakes = sumZones(stats, ['ShortLeft', 'AtRim', 'ShortRight', 'LeftMid', 'CenterMid', 'RightMid'], 'make');
      const twoMisses = sumZones(stats, ['ShortLeft', 'AtRim', 'ShortRight', 'LeftMid', 'CenterMid', 'RightMid'], 'miss');
      const threeMakes = sumZones(stats, ['LeftCorner', 'RightCorner', 'LeftWing', 'RightWing', 'CenterArc'], 'make');
      const threeMisses = sumZones(stats, ['LeftCorner', 'RightCorner', 'LeftWing', 'RightWing', 'CenterArc'], 'miss');

      const fgMakes = twoMakes + threeMakes;
      const fgAttempts = fgMakes + twoMisses + threeMisses;
      const threeAttempts = threeMakes + threeMisses;
      const ftAttempts = stats.ftMake + stats.ftMiss;
      const rebounds = stats.offReb + stats.defReb;
      const computedPoints = stats.ftMake + twoMakes * 2 + threeMakes * 3;

      return {
        fgMakes,
        fgAttempts,
        threeMakes,
        threeAttempts,
        ftMakes: stats.ftMake,
        ftAttempts,
        rebounds,
        points: computedPoints || stats.points,
        minutes: stats.minutesSeconds,
        ast: stats.ast,
        stl: stats.stl,
        blk: stats.blk,
        tov: stats.tov
      };
    }

    function sumZones(stats, zones, key) {
      return zones.reduce((total, zone) => total + (stats.zones[zone]?.[key] || 0), 0);
    }

    function formatPercent(makes, attempts) {
      if (!attempts) {
        return '--%';
      }
      return `${((makes / attempts) * 100).toFixed(1)}%`;
    }

    const statHeaderHtml = `
      <th>MIN</th>
      <th>PTS</th>
      <th>OREB</th>
      <th>DREB</th>
      <th>REB</th>
      <th>AST</th>
      <th>POT AST</th>
      <th>STL</th>
      <th>BLK</th>
      <th>BLK AG</th>
      <th>TO</th>
      <th>PF</th>
      <th>FC</th>
      <th>FG</th>
      <th>3PT</th>
      <th>FT</th>
    `;

    function renderAll() {
      const games = getSortedGames();
      const shotChartOptions = buildGameOptions(games, true);
      const teamBoxOptions = buildGameOptions(games, false);

      document.querySelectorAll('[data-role="shot-chart-select"]').forEach(select => {
        setSelectOptions(select, shotChartOptions, 'all');
        bindSelectOnce(select, () => {
          if (select.dataset.page === 'team') {
            updateTeamShotModeVisibility();
          } else {
            updatePlayerShotModeVisibility(select.dataset.page);
          }
          renderShotChartForPage(select.dataset.page, select.value);
          if (select.dataset.page === 'team') {
            renderTeamZoneBreakdown(state.selectedTeamZone, select.value);
          }
        });
      });

      document.querySelectorAll('[data-role="player-shot-mode"]').forEach(select => {
        select.value = select.value || 'totals';
        bindSelectOnce(select, () => {
          renderShotChartForPage(select.dataset.page, getShotChartSelection(select.dataset.page));
        });
      });

      const teamShotModeSelect = document.querySelector('[data-role="team-shot-mode"]');
      if (teamShotModeSelect) {
        teamShotModeSelect.value = state.teamShotMode;
        bindSelectOnce(teamShotModeSelect, () => {
          state.teamShotMode = teamShotModeSelect.value;
          renderShotChartForPage('team', getShotChartSelection('team'));
          renderTeamZoneBreakdown(state.selectedTeamZone, getShotChartSelection('team'));
        });
      }

      const teamViewSelect = document.querySelector('[data-role="team-view"]');
      if (teamViewSelect) {
        bindSelectOnce(teamViewSelect, () => renderTeamTable());
      }

      const teamBoxSelect = document.querySelector('[data-role="team-box-select"]');
      if (teamBoxSelect) {
        setSelectOptions(teamBoxSelect, teamBoxOptions, teamBoxOptions[0]?.value || '');
        bindSelectOnce(teamBoxSelect, () => renderTeamBoxScore());
      }

      renderPlayerTables();
      renderTeamTable();
      renderTeamBoxScore();
      renderAllShotCharts();
      const teamChart = document.querySelector('[data-role="shot-chart"][data-page="team"]');
      if (teamChart) {
        teamChart.querySelectorAll('.chart-zone').forEach(zone => zone.classList.remove('selected'));
      }
      setupTeamZoneClickHandler();
      updateTeamShotModeVisibility();
      updateAllPlayerShotModeVisibility();
      renderTeamZoneBreakdown(state.selectedTeamZone, getShotChartSelection('team'));
    }

    function getSortedGames() {
      return Object.values(state.games).slice().sort((a, b) => a.id.localeCompare(b.id));
    }

    function getShotChartSelection(pageKey) {
      const select = document.querySelector(`[data-role="shot-chart-select"][data-page="${pageKey}"]`);
      return select ? select.value : 'all';
    }

    function getTeamShotMode() {
      const select = document.querySelector('[data-role="team-shot-mode"]');
      if (select) {
        state.teamShotMode = select.value || state.teamShotMode;
      }
      return state.teamShotMode || 'totals';
    }

    function updateTeamShotModeVisibility() {
      const wrapper = document.querySelector('[data-role="team-shot-mode-wrapper"]');
      if (!wrapper) {
        return;
      }
      const show = getShotChartSelection('team') === 'all';
      wrapper.classList.toggle('hidden', !show);
    }

    function getPlayerShotMode(pageKey) {
      const select = document.querySelector(`[data-role="player-shot-mode"][data-page="${pageKey}"]`);
      return select ? select.value : 'totals';
    }

    function updatePlayerShotModeVisibility(pageKey) {
      const wrapper = document.querySelector(`[data-role="player-shot-mode-wrapper"][data-page="${pageKey}"]`);
      if (!wrapper) {
        return;
      }
      const show = getShotChartSelection(pageKey) === 'all';
      wrapper.classList.toggle('hidden', !show);
    }

    function updateAllPlayerShotModeVisibility() {
      roster.forEach(player => updatePlayerShotModeVisibility(String(player.number)));
    }

    function getGameCount() {
      return Object.keys(state.games).length;
    }

    function getGamesPlayedForPlayer(playerNumber) {
      const games = Object.values(state.games);
      let count = 0;
      games.forEach(game => {
        const stats = game.players[playerNumber];
        if (stats && stats.minutesSeconds > 0) {
          count += 1;
        }
      });
      return count;
    }

    function buildGameOptions(games, includeAll = true) {
      const options = [];
      if (includeAll) {
        options.push({ value: 'all', label: 'All Games' });
      }
      games.forEach(game => {
        const label = `${game.id} - ${game.date}`;
        options.push({ value: game.key, label });
      });
      return options;
    }

    function setSelectOptions(select, options, defaultValue) {
      select.innerHTML = '';
      options.forEach(option => {
        const opt = document.createElement('option');
        opt.value = option.value;
        opt.textContent = option.label;
        select.appendChild(opt);
      });
      if (defaultValue !== undefined) {
        select.value = defaultValue;
      } else if (options[0]) {
        select.value = options[0].value;
      }
    }

    function bindSelectOnce(select, handler) {
      if (select.dataset.bound) {
        return;
      }
      select.addEventListener('change', handler);
      select.dataset.bound = 'true';
    }

    function renderPlayerTables() {
      const games = getSortedGames();

      roster.forEach(player => {
        const gamesPlayed = getGamesPlayedForPlayer(player.number);
        const table = document.querySelector(`[data-role="player-log"][data-page="${player.number}"]`);
        if (!table) {
          return;
        }
        const thead = table.querySelector('thead');
        const tbody = table.querySelector('tbody');
        const tfoot = table.querySelector('tfoot');

        thead.innerHTML = buildStatHeaderHtml('Game', true);
        tbody.innerHTML = '';
        tfoot.innerHTML = '';

        games.forEach(game => {
          const stats = game.players[player.number] || createEmptyStats();
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${game.id}</td>
            <td>${game.date}</td>
            ${buildStatCells(stats, { isAverage: false })}
          `;
          tbody.appendChild(row);
        });

        const totals = state.overall.players[player.number];
        tfoot.appendChild(buildFooterRow('Totals', totals, true, false));
        tfoot.appendChild(buildFooterRow('Averages', totals, true, true, gamesPlayed));
      });
    }

    function renderTeamTable() {
      const table = document.querySelector('[data-role="team-table"]');
      const title = document.querySelector('[data-role="team-table-title"]');
      const viewSelect = document.querySelector('[data-role="team-view"]');
      if (!table || !viewSelect || !title) {
        return;
      }

      const view = viewSelect.value || 'averages';
      const games = getSortedGames();
      const gameCount = getGameCount();
      const thead = table.querySelector('thead');
      const tbody = table.querySelector('tbody');
      const tfoot = table.querySelector('tfoot');

      tbody.innerHTML = '';
      tfoot.innerHTML = '';

      if (view === 'team-game') {
        title.textContent = 'Team Game Log';
        thead.innerHTML = buildStatHeaderHtml('Game', true);

        games.forEach(game => {
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${game.id}</td>
            <td>${game.date}</td>
            ${buildStatCells(game.team, { isAverage: false })}
          `;
          tbody.appendChild(row);
        });

        const totals = state.overall.team;
        tfoot.appendChild(buildFooterRow('Team Totals', totals, true, false));
        tfoot.appendChild(buildFooterRow('Team Averages', totals, true, true, gameCount));
      } else {
        const isAverageView = view === 'averages';
        title.textContent = isAverageView ? 'Player Averages' : 'Player Totals';
        thead.innerHTML = buildStatHeaderHtml('Player', false, true);

        roster.forEach(player => {
          const stats = state.overall.players[player.number];
          const gamesPlayed = getGamesPlayedForPlayer(player.number);
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${player.name}</td>
            <td>${gamesPlayed}</td>
            ${buildStatCells(stats, { isAverage: isAverageView, averageDivisor: isAverageView ? gamesPlayed : 0 })}
          `;
          tbody.appendChild(row);
        });

        const teamLabel = isAverageView ? 'Team Averages' : 'Team Totals';
        tfoot.appendChild(buildFooterRowWithGp(teamLabel, gameCount, state.overall.team, isAverageView, isAverageView ? gameCount : 0));
      }
    }

    function renderTeamBoxScore() {
      const table = document.querySelector('[data-role="team-boxscore"]');
      const select = document.querySelector('[data-role="team-box-select"]');
      if (!table || !select) {
        return;
      }

      const games = getSortedGames();
      const thead = table.querySelector('thead');
      const tbody = table.querySelector('tbody');
      const tfoot = table.querySelector('tfoot');

      thead.innerHTML = buildStatHeaderHtml('Player', false);
      tbody.innerHTML = '';
      tfoot.innerHTML = '';

      if (!games.length) {
        return;
      }

      if (!select.value) {
        select.value = games[0].key;
      }

      const game = games.find(item => item.key === select.value) || games[0];
      roster.forEach(player => {
        const stats = game.players[player.number] || createEmptyStats();
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${player.name}</td>
          ${buildStatCells(stats, { isAverage: false })}
        `;
        tbody.appendChild(row);
      });

      tfoot.appendChild(buildFooterRow('Team Totals', game.team, false, false));
      renderTeamActionLog(game);
    }

    function renderTeamActionLog(game) {
      const logTable = document.querySelector('[data-role="team-action-log"] tbody');
      if (!logTable) {
        return;
      }
      logTable.innerHTML = '';
      const entries = Array.isArray(game?.actionLog) ? game.actionLog : [];
      if (!entries.length) {
        const row = document.createElement('tr');
        row.innerHTML = '<td>No action log entries found.</td>';
        logTable.appendChild(row);
        return;
      }
      entries.forEach(entry => {
        const row = document.createElement('tr');
        row.innerHTML = `<td>${entry}</td>`;
        logTable.appendChild(row);
      });
    }

    function renderAllShotCharts() {
      document.querySelectorAll('[data-role="shot-chart-select"]').forEach(select => {
        const pageKey = select.dataset.page;
        const value = select.value || 'all';
        renderShotChartForPage(pageKey, value);
      });
    }

    function setupTeamZoneClickHandler() {
      const container = document.querySelector('[data-role="shot-chart"][data-page="team"]');
      if (!container || container.dataset.bound) {
        return;
      }
      container.addEventListener('click', (event) => {
        const zoneBox = event.target.closest('.chart-zone');
        if (!zoneBox) {
          return;
        }
        const zoneKey = zoneBox.dataset.zone;
        if (!zoneKey) {
          return;
        }
        state.selectedTeamZone = zoneKey;
        container.querySelectorAll('.chart-zone').forEach(box => {
          box.classList.toggle('selected', box === zoneBox);
        });
        renderTeamZoneBreakdown(zoneKey, getShotChartSelection('team'));
      });
      container.dataset.bound = 'true';
    }

    function renderTeamZoneBreakdown(zoneKey, gameKey) {
      const breakdown = document.querySelector('[data-role="zone-breakdown"]');
      if (!breakdown) {
        return;
      }
      const title = breakdown.querySelector('[data-role="zone-breakdown-title"]');
      const tbody = breakdown.querySelector('tbody');
      if (!tbody || !title) {
        return;
      }

      tbody.innerHTML = '';
      if (!zoneKey) {
        title.textContent = 'Click a zone to see player splits';
        return;
      }

      const label = zoneLabels[zoneKey] || zoneKey;
      const isAverageMode = gameKey === 'all' && getTeamShotMode() === 'averages';
      const modeLabel = gameKey === 'all'
        ? (isAverageMode ? 'All Games (Avg)' : 'All Games')
        : 'Selected Game';
      title.textContent = `${label} splits (${modeLabel})`;

      let hasRows = false;
      roster.forEach(player => {
        const stats = getStatsFor(String(player.number), gameKey);
        const zone = stats?.zones?.[zoneKey] || { make: 0, miss: 0 };
        const divisor = isAverageMode ? getGamesPlayedForPlayer(player.number) : 1;
        const factor = isAverageMode ? (divisor ? 1 / divisor : 0) : 1;
        const makes = (zone.make || 0) * factor;
        const attempts = ((zone.make || 0) + (zone.miss || 0)) * factor;
        if (!attempts) {
          return;
        }
        const pct = attempts ? `${((zone.make / (zone.make + zone.miss)) * 100).toFixed(1)}%` : '--%';

        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${player.name}</td>
          <td>${formatShotValue(makes, isAverageMode)}-${formatShotValue(attempts, isAverageMode)}</td>
          <td>${pct}</td>
        `;
        tbody.appendChild(row);
        hasRows = true;
      });

      if (!hasRows) {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td colspan="3">No attempts recorded.</td>
        `;
        tbody.appendChild(row);
      }
    }

    function renderShotChartForPage(pageKey, gameKey) {
      const chartContainer = document.querySelector(`[data-role="shot-chart"][data-page="${pageKey}"]`);
      if (!chartContainer) {
        return;
      }
      const { stats, isAverage } = getShotChartStats(pageKey, gameKey);
      updateShotChart(chartContainer, stats, { isAverage });
    }

    function getStatsFor(pageKey, gameKey) {
      if (gameKey === 'all') {
        return pageKey === 'team' ? state.overall.team : state.overall.players[pageKey];
      }

      const game = state.games[gameKey];
      if (!game) {
        return pageKey === 'team' ? state.overall.team : state.overall.players[pageKey];
      }
      return pageKey === 'team' ? game.team : game.players[pageKey];
    }

    function getShotChartStats(pageKey, gameKey) {
      const baseStats = getStatsFor(pageKey, gameKey);
      if (gameKey !== 'all') {
        return { stats: baseStats, isAverage: false };
      }

      if (pageKey === 'team') {
        const mode = getTeamShotMode();
        if (mode !== 'averages') {
          return { stats: baseStats, isAverage: false };
        }

        const gameCount = getGameCount();
        if (!gameCount) {
          return { stats: baseStats, isAverage: false };
        }

        return { stats: scaleShotChartStats(baseStats, 1 / gameCount), isAverage: true };
      }

      const mode = getPlayerShotMode(pageKey);
      if (mode !== 'averages') {
        return { stats: baseStats, isAverage: false };
      }

      const playerNumber = parseInt(pageKey, 10);
      if (!Number.isFinite(playerNumber)) {
        return { stats: baseStats, isAverage: false };
      }
      const gamesPlayed = getGamesPlayedForPlayer(playerNumber);
      if (!gamesPlayed) {
        return { stats: baseStats, isAverage: false };
      }

      return { stats: scaleShotChartStats(baseStats, 1 / gamesPlayed), isAverage: true };
    }

    function scaleShotChartStats(stats, factor) {
      const scaled = createEmptyStats();
      zoneKeys.forEach(zone => {
        scaled.zones[zone].make = (stats.zones[zone]?.make || 0) * factor;
        scaled.zones[zone].miss = (stats.zones[zone]?.miss || 0) * factor;
      });
      return scaled;
    }

    function buildStatHeaderHtml(firstLabel, includeDate, includeGp = false) {
      const dateHeader = includeDate ? '<th>Date</th>' : '';
      const gpHeader = includeGp ? '<th>GP</th>' : '';
      return `
        <tr>
          <th>${firstLabel}</th>
          ${dateHeader}
          ${gpHeader}
          ${statHeaderHtml}
        </tr>
      `;
    }

    function buildStatCells(stats, options) {
      const isAverage = options.isAverage;
      const divisor = options.averageDivisor || 0;
      const factor = isAverage ? (divisor ? 1 / divisor : 0) : 1;
      const derived = buildDerived(stats);

      const minutes = stats.minutesSeconds * factor;
      const offReb = stats.offReb * factor;
      const defReb = stats.defReb * factor;
      const reb = (stats.offReb + stats.defReb) * factor;
      const ast = stats.ast * factor;
      const potAst = stats.potAst * factor;
      const stl = stats.stl * factor;
      const blk = stats.blk * factor;
      const blkAgainst = stats.blkAgainst * factor;
      const tov = stats.tov * factor;
      const foulCommitted = stats.foulCommitted * factor;
      const foulCalled = stats.foulCalled * factor;
      const points = derived.points * factor;

      const fgMakes = derived.fgMakes * factor;
      const fgAttempts = derived.fgAttempts * factor;
      const threeMakes = derived.threeMakes * factor;
      const threeAttempts = derived.threeAttempts * factor;
      const ftMakes = derived.ftMakes * factor;
      const ftAttempts = derived.ftAttempts * factor;

      return `
        <td>${formatDuration(minutes)}</td>
        <td>${formatNumber(points, isAverage)}</td>
        <td>${formatNumber(offReb, isAverage)}</td>
        <td>${formatNumber(defReb, isAverage)}</td>
        <td>${formatNumber(reb, isAverage)}</td>
        <td>${formatNumber(ast, isAverage)}</td>
        <td>${formatNumber(potAst, isAverage)}</td>
        <td>${formatNumber(stl, isAverage)}</td>
        <td>${formatNumber(blk, isAverage)}</td>
        <td>${formatNumber(blkAgainst, isAverage)}</td>
        <td>${formatNumber(tov, isAverage)}</td>
        <td>${formatNumber(foulCommitted, isAverage)}</td>
        <td>${formatNumber(foulCalled, isAverage)}</td>
        <td>${formatMakeAttempts(fgMakes, fgAttempts, isAverage)}</td>
        <td>${formatMakeAttempts(threeMakes, threeAttempts, isAverage)}</td>
        <td>${formatMakeAttempts(ftMakes, ftAttempts, isAverage)}</td>
      `;
    }

    function buildFooterRow(label, stats, includeDate, isAverage, averageDivisor = 0) {
      const row = document.createElement('tr');
      row.className = isAverage ? 'averages-row' : 'totals-row';
      const leadCells = includeDate ? `<td>${label}</td><td></td>` : `<td>${label}</td>`;
      row.innerHTML = `${leadCells}${buildStatCells(stats, { isAverage, averageDivisor })}`;
      return row;
    }

    function buildFooterRowWithGp(label, gpValue, stats, isAverage, averageDivisor = 0) {
      const row = document.createElement('tr');
      row.className = isAverage ? 'averages-row' : 'totals-row';
      row.innerHTML = `
        <td>${label}</td>
        <td>${gpValue ?? ''}</td>
        ${buildStatCells(stats, { isAverage, averageDivisor })}
      `;
      return row;
    }

    function formatNumber(value, isAverage) {
      const safe = Number.isFinite(value) ? value : 0;
      if (isAverage) {
        return safe.toFixed(1);
      }
      return Math.round(safe).toString();
    }

    function formatMakeAttempts(makes, attempts, isAverage) {
      if (isAverage) {
        return `${formatDecimal(makes)}-${formatDecimal(attempts)}`;
      }
      return `${Math.round(makes)}-${Math.round(attempts)}`;
    }

    function formatDecimal(value) {
      const safe = Number.isFinite(value) ? value : 0;
      return safe.toFixed(1);
    }

    function updateShotChart(container, stats, options = {}) {
      if (!container) {
        return;
      }
      const isAverage = options.isAverage === true;

      zoneKeys.forEach(zone => {
        const data = stats.zones[zone];
        const attempts = data.make + data.miss;
        const pct = attempts ? data.make / attempts : null;
        const box = container.querySelector(`[data-zone="${zone}"]`);
        const text = container.querySelector(`[data-zone-text="${zone}"]`);

        if (box) {
          box.style.backgroundColor = getZoneColorForZone(zone, pct, attempts);
        }
        if (text) {
          const pctText = attempts ? `${Math.round(pct * 100)}%` : '--%';
          const makeText = formatShotValue(data.make, isAverage);
          const attemptText = formatShotValue(attempts, isAverage);
          text.textContent = `${makeText}/${attemptText} (${pctText})`;
        }
      });
    }

    function formatShotValue(value, isAverage) {
      const safe = Number.isFinite(value) ? value : 0;
      return isAverage ? safe.toFixed(1) : Math.round(safe).toString();
    }

    function hexToRgb(hex) {
      const sanitized = hex.replace('#', '');
      const value = parseInt(sanitized, 16);
      return {
        r: (value >> 16) & 255,
        g: (value >> 8) & 255,
        b: value & 255
      };
    }

    function interpolateColor(startHex, endHex, t) {
      const start = hexToRgb(startHex);
      const end = hexToRgb(endHex);

      const r = Math.round(start.r + (end.r - start.r) * t);
      const g = Math.round(start.g + (end.g - start.g) * t);
      const b = Math.round(start.b + (end.b - start.b) * t);

      return `rgb(${r}, ${g}, ${b})`;
    }

    function getZoneColorForZone(zone, pct, attempts) {
      if (!attempts) {
        return '#e2e8f0';
      }
      const category = zoneCategoryLookup[zone] || 'midRange';
      const expected = zoneAverages[category] ?? 0.4;
      const spread = zoneRange || 0.2;
      const maxAttempts = maxAttemptsForIntensity || 10;

      const intensity = Math.min(attempts / maxAttempts, 1);
      const diff = pct === null ? 0 : pct - expected;
      const normalized = Math.max(-1, Math.min(1, diff / spread));

      const hue = 60 + normalized * 60;
      const targetSaturation = 70;
      const targetLightness = 55;
      const saturation = 5 + intensity * (targetSaturation - 5);
      const lightness = 96 - intensity * (96 - targetLightness);

      return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

  </script>
</body>
</html>
