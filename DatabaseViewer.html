<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Basketball Database Viewer</title>
  <style>
    :root {
      --bg: #f7f6f2;
      --panel: #ffffff;
      --ink: #0f172a;
      --muted: #6b7280;
      --accent: #0f172a;
      --accent-2: #e2e8f0;
      --good: #22c55e;
      --warn: #f97316;
      --bad: #ef4444;
      --stroke: #e5e7eb;
    }

    * {
      box-sizing: border-box;
    }

    .hidden {
      display: none;
    }

    body {
      margin: 0;
      font-family: "Georgia", "Times New Roman", serif;
      background: radial-gradient(circle at top, #ffffff 0%, #f3f4f6 35%, #ede9fe 100%);
      color: var(--ink);
    }

    header {
      padding: 24px 28px 12px;
    }

    h1 {
      margin: 0 0 6px 0;
      font-size: 28px;
      letter-spacing: 0.5px;
    }

    p {
      margin: 4px 0;
      color: var(--muted);
    }

    .upload-panel {
      margin: 16px 28px 0;
      background: var(--panel);
      border-radius: 16px;
      border: 1px solid var(--stroke);
      padding: 16px;
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.08);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .upload-row {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 12px;
    }

    input[type="file"] {
      padding: 8px;
      background: #f8fafc;
      border: 1px dashed var(--stroke);
      border-radius: 8px;
    }

    .tabs {
      margin: 18px 28px 0;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .tab-button {
      padding: 10px 16px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: #ffffff;
      cursor: pointer;
      font-weight: 700;
      color: var(--ink);
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.2s ease;
    }

    .tab-button.active {
      background: var(--accent);
      color: #ffffff;
      box-shadow: 0 12px 22px rgba(15, 23, 42, 0.22);
      transform: translateY(-1px);
    }

    main {
      padding: 16px 28px 40px;
    }

    .page {
      display: none;
      background: var(--panel);
      border-radius: 18px;
      border: 1px solid var(--stroke);
      padding: 20px;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.08);
      margin-bottom: 20px;
    }

    .page.active {
      display: block;
      animation: fadeIn 0.4s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .page-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 12px;
    }

    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 8px;
    }

    .section-header h3 {
      margin: 0;
    }

    .page-header h2 {
      margin: 0;
      font-size: 22px;
    }

    .filters {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--muted);
    }

    select {
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid var(--stroke);
      font-family: inherit;
    }

    .summary-grid {
      margin-top: 16px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
    }

    .summary-card {
      background: #f8fafc;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      padding: 12px;
      min-height: 82px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .summary-card .label {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.6px;
    }

    .summary-card .value {
      font-size: 20px;
      font-weight: 700;
      color: var(--ink);
    }

    .chart-section {
      margin-top: 20px;
    }

    .shot-chart-wrapper {
      background: linear-gradient(180deg, #f8fafc 0%, #e2e8f0 100%);
      border: 1px solid var(--stroke);
      border-radius: 16px;
      padding: 12px;
    }

    .shot-chart-grid {
      position: relative;
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      grid-template-rows: repeat(4, auto);
      gap: 16px;
      max-width: 820px;
      margin: 0 auto;
      padding: 12px 12px 28px 12px;
    }

    .shot-chart-grid::before {
      content: '';
      position: absolute;
      top: 6px;
      left: 50%;
      transform: translateX(-50%) rotate(180deg);
      width: 560px;
      height: 280px;
      background-color: #f5deb3;
      border-top-left-radius: 280px;
      border-top-right-radius: 280px;
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      border: 4px solid #111827;
      z-index: 0;
    }

    .chart-zone {
      position: relative;
      z-index: 1;
      background: #e2e8f0;
      border: 1px solid #cbd5e1;
      border-radius: 12px;
      min-height: 88px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.8);
      transition: background-color 0.25s ease;
    }

    .chart-zone .zone-name {
      font-weight: 700;
      font-size: 13px;
      text-align: center;
    }

    .chart-zone .zone-metrics {
      font-size: 12px;
      margin-top: 6px;
      color: #0f172a;
    }

    .chart-zone.selected {
      outline: 3px solid #0f172a;
      outline-offset: 2px;
    }

    .chart-zone.left-corner { grid-area: 1 / 1; }
    .chart-zone.short-left { grid-area: 1 / 2; }
    .chart-zone.at-rim { grid-area: 1 / 3; }
    .chart-zone.short-right { grid-area: 1 / 4; }
    .chart-zone.right-corner { grid-area: 1 / 5; }
    .chart-zone.left-mid { grid-area: 2 / 2; }
    .chart-zone.center-mid { grid-area: 2 / 3; }
    .chart-zone.right-mid { grid-area: 2 / 4; }
    .chart-zone.left-wing { grid-area: 3 / 1; }
    .chart-zone.center-arc { grid-area: 4 / 3; }
    .chart-zone.right-wing { grid-area: 3 / 5; }

    .game-log {
      margin-top: 20px;
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      min-width: 720px;
    }

    th, td {
      padding: 8px 6px;
      border: 1px solid var(--stroke);
      text-align: center;
    }

    th {
      background: var(--accent);
      color: #ffffff;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.4px;
    }

    td:first-child, th:first-child {
      text-align: left;
      font-weight: 700;
    }

    tfoot td {
      font-weight: 700;
      background: #f8fafc;
    }

    tfoot tr.averages-row td {
      background: #eef2ff;
    }

    .legend {
      margin-top: 8px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      font-size: 12px;
      color: var(--muted);
    }

    .legend span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .legend i {
      width: 14px;
      height: 10px;
      border-radius: 4px;
      border: 1px solid #cbd5e1;
      display: inline-block;
    }

    .legend .cold { background: #f87171; }
    .legend .neutral { background: #fbbf24; }
    .legend .hot { background: #34d399; }

    .zone-breakdown {
      margin-top: 14px;
      border: 1px solid var(--stroke);
      border-radius: 12px;
      background: #ffffff;
      padding: 12px;
    }

    .zone-breakdown h4 {
      margin: 0 0 8px 0;
      font-size: 14px;
    }

    .zone-breakdown table {
      min-width: 0;
      font-size: 12px;
    }

    .zone-breakdown td:first-child, .zone-breakdown th:first-child {
      text-align: left;
    }

    .nerdzone {
      margin-top: 12px;
    }

    .nerdzone-controls {
      display: flex;
      align-items: center;
      gap: 10px;
      color: var(--muted);
      font-size: 12px;
    }

    .nerdzone-graph {
      margin-top: 12px;
      background: #f8fafc;
      border: 1px solid var(--stroke);
      border-radius: 16px;
      padding: 16px;
    }

    .nerdzone-graph svg {
      width: 100%;
      height: 320px;
      display: block;
    }

    .nerdzone-empty {
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
    }

    .nerdzone-layout {
      display: flex;
      gap: 16px;
      align-items: flex-start;
      flex-wrap: wrap;
    }

    .nerdzone-breakdown {
      flex: 0 0 260px;
      border: 1px solid var(--stroke);
      border-radius: 12px;
      background: #ffffff;
      padding: 12px;
    }

    .nerdzone-breakdown h4 {
      margin: 0 0 8px 0;
      font-size: 13px;
      color: var(--ink);
    }

    .nerdzone-breakdown table {
      min-width: 0;
      font-size: 12px;
    }

    .nerd-node text {
      font-size: 11px;
      font-weight: 700;
      fill: #0f172a;
      cursor: pointer;
    }

    .nerd-node circle {
      fill: #f8fafc;
      stroke: #0f172a;
      stroke-width: 1.5;
    }

    .nerd-edge {
      stroke: #64748b;
      stroke-linecap: round;
      fill: none;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }

    .nerd-node.active circle {
      fill: #e2e8f0;
    }

    .nerd-node.active text {
      fill: #1d4ed8;
    }

    details.glossary {
      margin-top: 16px;
      border: 1px solid var(--stroke);
      border-radius: 12px;
      background: #ffffff;
      padding: 10px 12px;
    }

    details.glossary summary {
      cursor: pointer;
      font-weight: 700;
      color: var(--ink);
      list-style: none;
    }

    details.glossary summary::-webkit-details-marker {
      display: none;
    }

    .glossary-grid {
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 10px 14px;
    }

    .glossary-item h4 {
      margin: 0 0 4px 0;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.4px;
      color: var(--muted);
    }

    .glossary-item p {
      margin: 0 0 4px 0;
      font-size: 12px;
      color: var(--ink);
    }

    @media (max-width: 720px) {
      header, main {
        padding: 16px;
      }

      .upload-panel, .tabs {
        margin: 12px 16px 0;
      }
    }
  </style>
</head>
<body>
  <header id="pageHeader">
    <h1>Basketball Game Log Database</h1>
    <p>Upload a folder of CAMT.csv exports to summarize stats for the team and each player.</p>
  </header>

  <div class="upload-panel" id="uploadPanel">
    <div class="upload-row">
      <input type="file" id="folderInput" webkitdirectory multiple />
      <span id="uploadStatus">No files loaded.</span>
    </div>
    <p>Include a Roster.csv in the uploaded folder to set player numbers/names. Player IDs are matched by name or the last two digits.</p>
  </div>

  <div class="tabs hidden" id="pageTabs"></div>

  <main id="pages" class="hidden"></main>

  <script>
    const defaultRoster = [
      { number: 1, name: 'Mike' },
      { number: 2, name: 'Stanley' },
      { number: 3, name: 'Ryan' },
      { number: 4, name: 'Jim' },
      { number: 5, name: 'Dwight' }
    ];
    let roster = defaultRoster.slice();

    const zoneKeys = [
      'LeftCorner',
      'ShortLeft',
      'AtRim',
      'ShortRight',
      'RightCorner',
      'LeftMid',
      'CenterMid',
      'RightMid',
      'LeftWing',
      'CenterArc',
      'RightWing'
    ];

    const zoneLabels = {
      LeftCorner: 'Left Corner 3',
      ShortLeft: 'Short Left',
      AtRim: 'At Rim',
      ShortRight: 'Short Right',
      RightCorner: 'Right Corner 3',
      LeftMid: 'Left Mid',
      CenterMid: 'Center Mid',
      RightMid: 'Right Mid',
      LeftWing: 'Left Wing 3',
      CenterArc: 'Center Arc 3',
      RightWing: 'Right Wing 3'
    };

    const zoneColumnLabels = {
      LeftCorner: 'Left Corner',
      ShortLeft: 'Short Left',
      AtRim: 'At Rim',
      ShortRight: 'Short Right',
      RightCorner: 'Right Corner',
      LeftMid: 'Left Mid',
      CenterMid: 'Center Mid',
      RightMid: 'Right Mid',
      LeftWing: 'Left Wing',
      CenterArc: 'Center Arc',
      RightWing: 'Right Wing'
    };

    const zoneCategoryLookup = {
      LeftCorner: 'three',
      RightCorner: 'three',
      LeftWing: 'three',
      RightWing: 'three',
      CenterArc: 'three',
      AtRim: 'atRim',
      ShortLeft: 'midRange',
      ShortRight: 'midRange',
      LeftMid: 'midRange',
      CenterMid: 'midRange',
      RightMid: 'midRange'
    };

    const zoneAverages = {
      atRim: 0.6,
      midRange: 0.4,
      three: 0.3
    };

    const zoneRange = 0.2;
    const maxAttemptsForIntensity = 10;

    const state = {
      games: {},
      teamShotMode: 'totals',
      selectedTeamZone: null,
      nerdHover: null,
      nerdSelection: 'all-total',
      nerdMatrix: {},
      nerdIsAverage: false,
      overall: {
        team: createEmptyStats(),
        players: createRosterStats()
      }
    };

    const pageTabs = document.getElementById('pageTabs');
    const pagesContainer = document.getElementById('pages');

    document.getElementById('folderInput').addEventListener('change', async (event) => {
      const allFiles = Array.from(event.target.files || []);
      const rosterFile = allFiles.find(file => file.name.toLowerCase() === 'roster.csv');
      const files = allFiles.filter(file => file.name.toLowerCase().endsWith('.csv') && file !== rosterFile);
      if (!rosterFile) {
        setLoadedState(false);
        document.getElementById('uploadStatus').textContent = 'Roster.csv is required. Add it to the folder before uploading.';
        return;
      }
      if (!files.length) {
        setLoadedState(false);
        document.getElementById('uploadStatus').textContent = 'No CSV files found in that folder.';
        return;
      }

      document.getElementById('uploadStatus').textContent = `Loading ${files.length} file(s)...`;
      const rosterText = await rosterFile.text();
      const parsedRoster = parseRosterCsv(rosterText);
      if (!parsedRoster.length) {
        roster = [];
        rebuildPages();
        setLoadedState(false);
        document.getElementById('uploadStatus').textContent = 'Roster.csv is required and must include Number,Name columns with valid rows.';
        return;
      }
      roster = parsedRoster;
      rebuildPages();
      resetState();

      const parsedFiles = await Promise.all(files.map(file => parseCsvFile(file)));
      parsedFiles.forEach((result) => {
        if (result) {
          state.games[result.key] = result.game;
        }
      });

      buildOverallTotals();
      renderAll();
      const rosterSummary = roster.map(player => `#${player.number} ${player.name}`).join(', ');
      document.getElementById('uploadStatus').textContent = `Loaded ${Object.keys(state.games).length} game(s). Roster: ${rosterSummary}`;
      setLoadedState(true);
    });

    function initPages() {
      const pages = [{ key: 'team', label: 'Team' }, { key: 'nerd', label: 'NerdZone' }].concat(
        roster.map(player => ({ key: String(player.number), label: `#${player.number} ${player.name}` }))
      );

      pages.forEach((page, index) => {
        const button = document.createElement('button');
        button.className = `tab-button${index === 0 ? ' active' : ''}`;
        button.textContent = page.label;
        button.dataset.page = page.key;
        pageTabs.appendChild(button);

        const section = document.createElement('section');
        section.className = `page${index === 0 ? ' active' : ''}`;
        section.dataset.page = page.key;
        section.innerHTML = buildPageHtml(page);
        pagesContainer.appendChild(section);
      });

      if (!pageTabs.dataset.bound) {
        pageTabs.addEventListener('click', (event) => {
          const target = event.target.closest('button[data-page]');
          if (!target) {
            return;
          }
          const pageKey = target.dataset.page;
          pageTabs.querySelectorAll('button').forEach(btn => btn.classList.toggle('active', btn === target));
          pagesContainer.querySelectorAll('.page').forEach(page => page.classList.toggle('active', page.dataset.page === pageKey));
        });
        pageTabs.dataset.bound = 'true';
      }
    }

    function rebuildPages() {
      pageTabs.innerHTML = '';
      pagesContainer.innerHTML = '';
      initPages();
    }

    function setLoadedState(isLoaded) {
      const tabs = document.getElementById('pageTabs');
      const pages = document.getElementById('pages');
      const uploadPanel = document.getElementById('uploadPanel');
      const header = document.getElementById('pageHeader');
      if (tabs) {
        tabs.classList.toggle('hidden', !isLoaded);
      }
      if (pages) {
        pages.classList.toggle('hidden', !isLoaded);
      }
      if (uploadPanel) {
        uploadPanel.classList.toggle('hidden', isLoaded);
        uploadPanel.style.display = isLoaded ? 'none' : '';
      }
      if (header) {
        header.classList.toggle('hidden', isLoaded);
        header.style.display = isLoaded ? 'none' : '';
      }
    }

    setLoadedState(false);

    function parseRosterCsv(text) {
      const rows = parseCsv(text);
      if (!rows.length) {
        return [];
      }
      const header = rows[0].map(value => value.trim().toLowerCase());
      const numberIndex = header.indexOf('number');
      const nameIndex = header.indexOf('name');
      if (numberIndex === -1 || nameIndex === -1) {
        return [];
      }
      const parsed = [];
      for (let i = 1; i < rows.length; i++) {
        const row = rows[i];
        if (!row || row.length === 0) {
          continue;
        }
        const rawNumber = row[numberIndex];
        const rawName = row[nameIndex];
        const number = Number.parseInt(String(rawNumber || '').trim(), 10);
        const name = String(rawName || '').trim();
        if (!Number.isFinite(number) || !name) {
          continue;
        }
        parsed.push({ number, name });
      }
      return parsed;
    }

    function isRosterNumber(playerNumber) {
      return roster.some(player => player.number === playerNumber);
    }

    function parseActionEntry(entry) {
      const match = String(entry || '').match(/^(\d+:\d{2})\s+(\d+)\s+(.*)$/);
      if (!match) {
        return null;
      }
      const time = match[1];
      const playerNumber = Number.parseInt(match[2], 10);
      if (!Number.isFinite(playerNumber)) {
        return null;
      }
      return {
        time,
        playerNumber,
        message: match[3] || ''
      };
    }

    function deriveAssistedMakes(entries) {
      const makesByTime = new Map();
      const assistsByTime = new Map();

      entries.forEach(entry => {
        const parsed = parseActionEntry(entry);
        if (!parsed || !isRosterNumber(parsed.playerNumber)) {
          return;
        }
        const message = parsed.message.toLowerCase();

        if (message.includes('made a 2-pointer') || message.includes('made a 3-pointer')) {
          if (!makesByTime.has(parsed.time)) {
            makesByTime.set(parsed.time, []);
          }
          makesByTime.get(parsed.time).push(parsed.playerNumber);
          return;
        }

        if (message.includes('had an assist')) {
          assistsByTime.set(parsed.time, (assistsByTime.get(parsed.time) || 0) + 1);
        }
      });

      const assistedByPlayer = {};
      makesByTime.forEach((makers, time) => {
        const assistCount = assistsByTime.get(time) || 0;
        makers.forEach((playerNumber, index) => {
          if (index < assistCount) {
            assistedByPlayer[playerNumber] = (assistedByPlayer[playerNumber] || 0) + 1;
          }
        });
      });

      return assistedByPlayer;
    }

    function deriveAssistPairs(entries) {
      const makesByTime = new Map();
      const pairs = {};

      entries.forEach(entry => {
        const parsed = parseActionEntry(entry);
        if (!parsed || !isRosterNumber(parsed.playerNumber)) {
          return;
        }
        const message = parsed.message.toLowerCase();

        if (message.includes('made a 2-pointer') || message.includes('made a 3-pointer')) {
          if (!makesByTime.has(parsed.time)) {
            makesByTime.set(parsed.time, []);
          }
          makesByTime.get(parsed.time).push(parsed.playerNumber);
          return;
        }

        if (message.includes('had an assist')) {
          const queue = makesByTime.get(parsed.time);
          if (!queue || !queue.length) {
            return;
          }
          const scorer = queue.shift();
          if (!isRosterNumber(scorer)) {
            return;
          }
          if (!pairs[parsed.playerNumber]) {
            pairs[parsed.playerNumber] = {};
          }
          pairs[parsed.playerNumber][scorer] = (pairs[parsed.playerNumber][scorer] || 0) + 1;
        }
      });

      return pairs;
    }

    // Pages are created after a successful upload.

    function buildPageHtml(page) {
      if (page.key === 'nerd') {
        return `
          <div class="page-header">
            <h2>NerdZone</h2>
          </div>
          <div class="nerdzone">
            <div class="section-header">
              <h3>Assist Network</h3>
              <div class="nerdzone-controls">
                <label for="nerdFilter">View</label>
                <select id="nerdFilter" data-role="nerd-filter"></select>
                <span>Green = assists given, Blue = assists received.</span>
              </div>
            </div>
            <div class="nerdzone-layout">
              <div class="nerdzone-graph">
                <svg viewBox="0 0 600 320" data-role="nerdzone-svg" aria-label="Assist network" role="img" preserveAspectRatio="xMidYMid meet"></svg>
                <div class="nerdzone-empty hidden" data-role="nerdzone-empty">No assist connections yet.</div>
              </div>
              <div class="nerdzone-breakdown">
                <h4 data-role="nerd-breakdown-title">Hover a player to see assist breakdown</h4>
                <table data-role="nerd-breakdown-table">
                  <thead>
                    <tr>
                      <th>Player</th>
                      <th>Given</th>
                      <th>Received</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
              </div>
            </div>
          </div>
        `;
      }

      if (page.key === 'team') {
        return `
          <div class="page-header">
            <h2>Team Summary</h2>
            <div class="filters">
              <label>View</label>
              <select data-role="team-view">
                <option value="averages">Averages</option>
                <option value="totals">Totals</option>
                <option value="team-game">Team Game</option>
              </select>
            </div>
          </div>
          <div class="game-log">
            <div class="section-header">
              <h3 data-role="team-table-title">Player Averages</h3>
            </div>
            <table data-role="team-table">
              <thead></thead>
              <tbody></tbody>
              <tfoot></tfoot>
            </table>
          </div>
          ${glossaryHtml}
          <div class="chart-section">
            <div class="section-header">
              <h3>Shot Chart</h3>
              <div class="filters">
                <label>Game</label>
                <select data-role="shot-chart-select" data-page="team"></select>
                <span class="filters hidden" data-role="team-shot-mode-wrapper">
                  <label>Mode</label>
                  <select data-role="team-shot-mode">
                    <option value="totals">Totals</option>
                    <option value="averages">Averages</option>
                  </select>
                </span>
              </div>
            </div>
            <div class="shot-chart-wrapper">
              <div class="shot-chart-grid" data-role="shot-chart" data-page="team">
                ${zoneKeys.map(zone => `
                  <div class="chart-zone ${zoneToClass(zone)}" data-zone="${zone}">
                    <div class="zone-name">${zoneLabels[zone]}</div>
                    <div class="zone-metrics" data-zone-text="${zone}">0/0 (--%)</div>
                  </div>
                `).join('')}
              </div>
            </div>
            <div class="legend">
              <span><i class="cold"></i>Cold</span>
              <span><i class="neutral"></i>Average</span>
              <span><i class="hot"></i>Hot</span>
            </div>
            <div class="zone-breakdown" data-role="zone-breakdown">
              <h4 data-role="zone-breakdown-title">Click a zone to see player splits</h4>
              <table data-role="zone-breakdown-table">
                <thead>
                  <tr>
                    <th>No.</th>
                    <th>Player</th>
                    <th>FGM</th>
                    <th>FGA</th>
                    <th>FG%</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
          <div class="game-log">
            <div class="section-header">
              <h3>Game Box Score</h3>
              <div class="filters">
                <label>Game</label>
                <select data-role="team-box-select"></select>
              </div>
            </div>
            <table data-role="team-boxscore">
              <thead></thead>
              <tbody></tbody>
              <tfoot></tfoot>
            </table>
          </div>
          <div class="game-log">
            <div class="section-header">
              <h3>Game Log</h3>
            </div>
            <div class="zone-breakdown">
              <table data-role="team-action-log">
                <thead>
                  <tr>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
        `;
      }

      return `
        <div class="page-header">
          <h2>Player Summary: ${page.label}</h2>
        </div>
        <div class="game-log">
          <div class="section-header">
            <h3>Standard</h3>
          </div>
          <table data-role="player-log" data-page="${page.key}">
            <thead></thead>
            <tbody></tbody>
            <tfoot></tfoot>
          </table>
        </div>
        <div class="game-log">
          <div class="section-header">
            <h3>Advanced</h3>
          </div>
          <table data-role="player-advanced" data-page="${page.key}">
            <thead></thead>
            <tbody></tbody>
            <tfoot></tfoot>
          </table>
        </div>
        ${glossaryHtml}
        <div class="chart-section">
          <div class="section-header">
            <h3>Shot Chart</h3>
            <div class="filters">
              <label>Game</label>
              <select data-role="shot-chart-select" data-page="${page.key}"></select>
              <span class="filters hidden" data-role="player-shot-mode-wrapper" data-page="${page.key}">
                <label>Mode</label>
                <select data-role="player-shot-mode" data-page="${page.key}">
                  <option value="totals">Totals</option>
                  <option value="averages">Averages</option>
                </select>
              </span>
            </div>
          </div>
          <div class="shot-chart-wrapper">
            <div class="shot-chart-grid" data-role="shot-chart" data-page="${page.key}">
              ${zoneKeys.map(zone => `
                <div class="chart-zone ${zoneToClass(zone)}" data-zone="${zone}">
                  <div class="zone-name">${zoneLabels[zone]}</div>
                  <div class="zone-metrics" data-zone-text="${zone}">0/0 (--%)</div>
                </div>
              `).join('')}
            </div>
          </div>
          <div class="legend">
            <span><i class="cold"></i>Cold</span>
            <span><i class="neutral"></i>Average</span>
            <span><i class="hot"></i>Hot</span>
          </div>
        </div>
      `;
    }

    function zoneToClass(zone) {
      return zone.replace(/[A-Z]/g, (match, offset) => (offset === 0 ? match.toLowerCase() : `-${match.toLowerCase()}`));
    }

    function createEmptyStats() {
      const zones = {};
      zoneKeys.forEach(zone => {
        zones[zone] = { make: 0, miss: 0 };
      });
      return {
        minutesSeconds: 0,
        offReb: 0,
        defReb: 0,
        ast: 0,
        potAst: 0,
        tov: 0,
        stl: 0,
        blk: 0,
        blkAgainst: 0,
        foulCommitted: 0,
        foulCalled: 0,
        ftMake: 0,
        ftMiss: 0,
        points: 0,
        zones
      };
    }

    function createRosterStats() {
      const players = {};
      roster.forEach(player => {
        players[player.number] = createEmptyStats();
      });
      return players;
    }

    function resetState() {
      state.games = {};
      state.teamShotMode = 'totals';
      state.selectedTeamZone = null;
      state.nerdHover = null;
      state.nerdSelection = 'all-total';
      state.nerdMatrix = {};
      state.nerdIsAverage = false;
      state.overall.team = createEmptyStats();
      state.overall.players = createRosterStats();
    }

    function addStats(target, source) {
      if (!source) {
        return;
      }
      target.minutesSeconds += source.minutesSeconds || 0;
      target.offReb += source.offReb || 0;
      target.defReb += source.defReb || 0;
      target.ast += source.ast || 0;
      target.potAst += source.potAst || 0;
      target.tov += source.tov || 0;
      target.stl += source.stl || 0;
      target.blk += source.blk || 0;
      target.blkAgainst += source.blkAgainst || 0;
      target.foulCommitted += source.foulCommitted || 0;
      target.foulCalled += source.foulCalled || 0;
      target.ftMake += source.ftMake || 0;
      target.ftMiss += source.ftMiss || 0;
      target.points += source.points || 0;

      zoneKeys.forEach(zone => {
        target.zones[zone].make += source.zones[zone].make || 0;
        target.zones[zone].miss += source.zones[zone].miss || 0;
      });
    }

    function buildOverallTotals() {
      Object.values(state.games).forEach(game => {
        addStats(state.overall.team, game.team);
        roster.forEach(player => {
          addStats(state.overall.players[player.number], game.players[player.number]);
        });
      });
    }

    async function parseCsvFile(file) {
      const text = await file.text();
      const rows = parseCsv(text);
      if (!rows.length) {
        return null;
      }

      const header = rows[0];
      const headerMap = {};
      header.forEach((value, index) => {
        headerMap[value.trim()] = index;
      });

      let gameId = '';
      let gameDate = '';
      const gamePlayers = createRosterStats();
      let teamStats = null;
      const actionLog = [];
      let inActionLog = false;

      for (let i = 1; i < rows.length; i++) {
        const row = rows[i];
        if (!row || row.length === 0) {
          continue;
        }
        if (row[0] && row[0].trim() === 'Action Log') {
          inActionLog = true;
          continue;
        }

        if (inActionLog) {
          const entry = String(row[0] || '').trim();
          if (entry) {
            actionLog.push(entry);
          }
          continue;
        }

        const playerName = getValue(row, headerMap, 'Player Name');
        const gameIdValue = getValue(row, headerMap, 'Game ID');
        const dateValue = getValue(row, headerMap, 'Date');

        if (!gameId && gameIdValue && gameIdValue !== 'N/A') {
          gameId = gameIdValue;
        }
        if (!gameDate && dateValue && dateValue !== 'N/A') {
          gameDate = dateValue;
        }

        if (playerName && playerName.toLowerCase() === 'team totals') {
          teamStats = parseStatsRow(row, headerMap);
          continue;
        }

        const playerNumber = matchRosterNumber(row, headerMap, playerName);
        if (!playerNumber) {
          continue;
        }

        addStats(gamePlayers[playerNumber], parseStatsRow(row, headerMap));
      }

      if (!teamStats) {
        teamStats = createEmptyStats();
        roster.forEach(player => {
          addStats(teamStats, gamePlayers[player.number]);
        });
      }
      const summedTeamMinutes = Object.values(gamePlayers).reduce((total, player) => {
        return total + (player?.minutesSeconds || 0);
      }, 0);
      teamStats.minutesSeconds = summedTeamMinutes;

      const gameKey = file.name;
      const assistedMakesByPlayer = deriveAssistedMakes(actionLog);
      const assistPairs = deriveAssistPairs(actionLog);

      const game = {
        key: gameKey,
        id: gameId || file.name.replace(/\.csv$/i, ''),
        date: gameDate || 'Unknown',
        team: teamStats,
        players: gamePlayers,
        actionLog,
        assistedMakesByPlayer,
        assistPairs
      };

      return { key: gameKey, game };
    }

    function parseStatsRow(row, headerMap) {
      const stats = createEmptyStats();
      stats.offReb = toNumber(getValue(row, headerMap, 'Offensive Rebound'));
      stats.defReb = toNumber(getValue(row, headerMap, 'Defensive Rebound'));
      stats.ast = toNumber(getValue(row, headerMap, 'Assist'));
      stats.potAst = toNumber(getValue(row, headerMap, 'Potential Assist'));
      stats.tov = toNumber(getValue(row, headerMap, 'Turnover'));
      stats.stl = toNumber(getValue(row, headerMap, 'Steal'));
      stats.blk = toNumber(getValue(row, headerMap, 'Block'));
      stats.blkAgainst = toNumber(getValue(row, headerMap, 'Block Against'));
      stats.foulCommitted = toNumber(getValue(row, headerMap, 'Foul Committed'));
      stats.foulCalled = toNumber(getValue(row, headerMap, 'Foul Called'));
      stats.ftMake = toNumber(getValue(row, headerMap, 'FT Make'));
      stats.ftMiss = toNumber(getValue(row, headerMap, 'FT Miss'));
      stats.minutesSeconds = parseTimeToSeconds(getValue(row, headerMap, 'Minutes'));
      stats.points = toNumber(getValue(row, headerMap, 'Points'));

      zoneKeys.forEach(zone => {
        const makeLabel = `${zoneColumnLabels[zone]} Makes`;
        const missLabel = `${zoneColumnLabels[zone]} Misses`;
        stats.zones[zone].make = toNumber(getValue(row, headerMap, makeLabel));
        stats.zones[zone].miss = toNumber(getValue(row, headerMap, missLabel));
      });

      return stats;
    }

    function matchRosterNumber(row, headerMap, playerName) {
      const normalizedName = String(playerName || '').trim().toLowerCase();
      const matchedByName = roster.find(player => player.name.toLowerCase() === normalizedName);
      if (matchedByName) {
        return matchedByName.number;
      }

      const playerId = String(getValue(row, headerMap, 'Player ID') || '').trim();
      const suffix = playerId.slice(-2);
      const number = parseInt(suffix, 10);
      if (roster.some(player => player.number === number)) {
        return number;
      }

      return null;
    }

    function getValue(row, headerMap, headerName) {
      const index = headerMap[headerName];
      if (index === undefined) {
        return '';
      }
      return row[index] || '';
    }

    function toNumber(value) {
      const num = parseInt(String(value || '0').trim(), 10);
      return Number.isFinite(num) ? num : 0;
    }

    function parseTimeToSeconds(value) {
      if (!value) {
        return 0;
      }
      const trimmed = String(value).trim();
      if (!trimmed.includes(':')) {
        const numericMinutes = Number.parseFloat(trimmed);
        if (Number.isFinite(numericMinutes)) {
          return Math.round(numericMinutes * 60);
        }
        return 0;
      }
      const parts = trimmed.split(':').map(part => parseInt(part, 10));
      if (parts.some(part => Number.isNaN(part))) {
        return 0;
      }
      if (parts.length === 3) {
        return parts[0] * 3600 + parts[1] * 60 + parts[2];
      }
      if (parts.length === 2) {
        return parts[0] * 60 + parts[1];
      }
      return 0;
    }

    function formatDuration(seconds) {
      const total = Math.max(0, Math.round(seconds));
      const hrs = Math.floor(total / 3600);
      const mins = Math.floor((total % 3600) / 60);
      const secs = total % 60;
      if (hrs > 0) {
        return `${pad(hrs)}:${pad(mins)}:${pad(secs)}`;
      }
      return `${pad(mins)}:${pad(secs)}`;
    }

    function pad(value) {
      return String(value).padStart(2, '0');
    }

    function parseCsv(text) {
      const rows = [];
      let row = [];
      let current = '';
      let inQuotes = false;

      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        const next = text[i + 1];

        if (char === '"') {
          if (inQuotes && next === '"') {
            current += '"';
            i++;
          } else {
            inQuotes = !inQuotes;
          }
          continue;
        }

        if (char === ',' && !inQuotes) {
          row.push(current);
          current = '';
          continue;
        }

        if ((char === '\n' || char === '\r') && !inQuotes) {
          if (char === '\r' && next === '\n') {
            i++;
          }
          row.push(current);
          if (row.length && row.some(cell => cell !== '')) {
            rows.push(row);
          }
          row = [];
          current = '';
          continue;
        }

        current += char;
      }

      if (current || row.length) {
        row.push(current);
        if (row.length && row.some(cell => cell !== '')) {
          rows.push(row);
        }
      }

      return rows;
    }

    function buildDerived(stats) {
      const twoMakes = sumZones(stats, ['ShortLeft', 'AtRim', 'ShortRight', 'LeftMid', 'CenterMid', 'RightMid'], 'make');
      const twoMisses = sumZones(stats, ['ShortLeft', 'AtRim', 'ShortRight', 'LeftMid', 'CenterMid', 'RightMid'], 'miss');
      const threeMakes = sumZones(stats, ['LeftCorner', 'RightCorner', 'LeftWing', 'RightWing', 'CenterArc'], 'make');
      const threeMisses = sumZones(stats, ['LeftCorner', 'RightCorner', 'LeftWing', 'RightWing', 'CenterArc'], 'miss');

      const fgMakes = twoMakes + threeMakes;
      const fgAttempts = fgMakes + twoMisses + threeMisses;
      const threeAttempts = threeMakes + threeMisses;
      const ftAttempts = stats.ftMake + stats.ftMiss;
      const rebounds = stats.offReb + stats.defReb;
      const computedPoints = stats.ftMake + twoMakes * 2 + threeMakes * 3;

      return {
        fgMakes,
        fgAttempts,
        threeMakes,
        threeAttempts,
        ftMakes: stats.ftMake,
        ftAttempts,
        rebounds,
        points: computedPoints || stats.points,
        minutes: stats.minutesSeconds,
        ast: stats.ast,
        stl: stats.stl,
        blk: stats.blk,
        tov: stats.tov
      };
    }

    function sumZones(stats, zones, key) {
      return zones.reduce((total, zone) => total + (stats.zones[zone]?.[key] || 0), 0);
    }

    function formatPercent(makes, attempts) {
      if (!attempts) {
        return '--%';
      }
      return `${((makes / attempts) * 100).toFixed(1)}%`;
    }

    const statHeaderHtml = `
      <th>MIN</th>
      <th>PTS</th>
      <th>FGM</th>
      <th>FGA</th>
      <th>FG%</th>
      <th>3PM</th>
      <th>3PA</th>
      <th>3PT%</th>
      <th>FTM</th>
      <th>FTA</th>
      <th>FT%</th>
      <th>OREB</th>
      <th>DREB</th>
      <th>REB</th>
      <th>AST</th>
      <th>STL</th>
      <th>BLK</th>
      <th>TO</th>
      <th>PF</th>
    `;

    const advancedHeaderHtml = `
      <th>POT AST</th>
      <th>AST%</th>
      <th>BLK AG</th>
      <th>FOULS DRAWN</th>
      <th>FG %AST</th>
      <th>TS%</th>
      <th>eFG%</th>
      <th>USG%</th>
      <th>GMSC</th>
    `;

    const glossaryHtml = `
      <details class="glossary">
        <summary>Glossary & Formulas</summary>
        <div class="glossary-grid">
          <div class="glossary-item">
            <h4>MIN</h4>
            <p>Total minutes played.</p>
          </div>
          <div class="glossary-item">
            <h4>PTS</h4>
            <p>Points scored.</p>
            <p>Formula: 1*FTM + 2*(2PM) + 3*(3PM).</p>
          </div>
          <div class="glossary-item">
            <h4>FG / 3PT / FT</h4>
            <p>Field goals / threes / free throws makes and attempts.</p>
            <p>Example: FGM and FGA are shown separately.</p>
          </div>
          <div class="glossary-item">
            <h4>FG% / 3PT% / FT%</h4>
            <p>Percent makes.</p>
            <p>Formula: makes / attempts * 100.</p>
          </div>
          <div class="glossary-item">
            <h4>OREB / DREB / REB</h4>
            <p>Offensive, defensive, total rebounds.</p>
            <p>Formula: REB = OREB + DREB.</p>
          </div>
          <div class="glossary-item">
            <h4>AST / STL / BLK / TO / PF</h4>
            <p>Assists, steals, blocks, turnovers, personal fouls.</p>
          </div>
          <div class="glossary-item">
            <h4>POT AST</h4>
            <p>Potential assists recorded after missed shots.</p>
          </div>
          <div class="glossary-item">
            <h4>BLK AG</h4>
            <p>Shots blocked against the player.</p>
          </div>
          <div class="glossary-item">
            <h4>FOULS DRAWN</h4>
            <p>Fouls called on opponents by the player.</p>
          </div>
          <div class="glossary-item">
            <h4>FG %AST</h4>
            <p>Percent of a player's made FGs that were assisted.</p>
            <p>Formula: assisted FGM / FGM * 100.</p>
          </div>
          <div class="glossary-item">
            <h4>eFG%</h4>
            <p>Effective FG% (credits 3s).</p>
            <p>Formula: (FGM + 0.5*3PM) / FGA.</p>
          </div>
          <div class="glossary-item">
            <h4>TS%</h4>
            <p>True Shooting % (overall scoring efficiency).</p>
            <p>Formula: PTS / (2*FGA + 0.44*FTA).</p>
          </div>
          <div class="glossary-item">
            <h4>USG%</h4>
            <p>Usage % (share of team plays used while on floor).</p>
            <p>Formula: 100 * ((FGA + 0.44*FTA + TOV) * (Tm MP/5)) / (MP * (Tm FGA + 0.44*Tm FTA + Tm TOV)).</p>
          </div>
          <div class="glossary-item">
            <h4>GMSC</h4>
            <p>Game Score (overall game impact).</p>
            <p>Formula: PTS + 0.4*FGM - 0.7*FGA - 0.4*(FTA - FTM) + 0.7*ORB + 0.3*DRB + STL + 0.7*AST + 0.7*BLK - 0.4*PF - TOV.</p>
          </div>
          <div class="glossary-item">
            <h4>AST%</h4>
            <p>Assist percentage.</p>
            <p>Formula: 100 * AST / (((MP / (Tm MP/5)) * Tm FGM) - FGM).</p>
          </div>
          <div class="glossary-item">
            <h4>GP</h4>
            <p>Games played (minutes &gt; 0).</p>
          </div>
        </div>
      </details>
    `;

    function renderAll() {
      const games = getSortedGames();
      const shotChartOptions = buildGameOptions(games, true);
      const teamBoxOptions = buildGameOptions(games, false);

      const nerdFilter = document.querySelector('[data-role="nerd-filter"]');
      if (nerdFilter) {
        const nerdOptions = buildNerdOptions(games);
        const defaultValue = nerdOptions.some(option => option.value === state.nerdSelection)
          ? state.nerdSelection
          : nerdOptions[0]?.value;
        setSelectOptions(nerdFilter, nerdOptions, defaultValue);
        state.nerdSelection = nerdFilter.value;
        bindSelectOnce(nerdFilter, () => {
          state.nerdSelection = nerdFilter.value;
          renderNerdZone();
        });
      }

      document.querySelectorAll('[data-role="shot-chart-select"]').forEach(select => {
        setSelectOptions(select, shotChartOptions, 'all');
        bindSelectOnce(select, () => {
          if (select.dataset.page === 'team') {
            updateTeamShotModeVisibility();
          } else {
            updatePlayerShotModeVisibility(select.dataset.page);
          }
          renderShotChartForPage(select.dataset.page, select.value);
          if (select.dataset.page === 'team') {
            renderTeamZoneBreakdown(state.selectedTeamZone, select.value);
          }
        });
      });

      document.querySelectorAll('[data-role="player-shot-mode"]').forEach(select => {
        select.value = select.value || 'totals';
        bindSelectOnce(select, () => {
          renderShotChartForPage(select.dataset.page, getShotChartSelection(select.dataset.page));
        });
      });

      const teamShotModeSelect = document.querySelector('[data-role="team-shot-mode"]');
      if (teamShotModeSelect) {
        teamShotModeSelect.value = state.teamShotMode;
        bindSelectOnce(teamShotModeSelect, () => {
          state.teamShotMode = teamShotModeSelect.value;
          renderShotChartForPage('team', getShotChartSelection('team'));
          renderTeamZoneBreakdown(state.selectedTeamZone, getShotChartSelection('team'));
        });
      }

      const teamViewSelect = document.querySelector('[data-role="team-view"]');
      if (teamViewSelect) {
        bindSelectOnce(teamViewSelect, () => renderTeamTable());
      }

      const teamBoxSelect = document.querySelector('[data-role="team-box-select"]');
      if (teamBoxSelect) {
        setSelectOptions(teamBoxSelect, teamBoxOptions, teamBoxOptions[0]?.value || '');
        bindSelectOnce(teamBoxSelect, () => renderTeamBoxScore());
      }

      renderPlayerTables();
      renderPlayerAdvancedTables();
      renderTeamTable();
      renderTeamBoxScore();
      renderNerdZone();
      renderAllShotCharts();
      const teamChart = document.querySelector('[data-role="shot-chart"][data-page="team"]');
      if (teamChart) {
        teamChart.querySelectorAll('.chart-zone').forEach(zone => zone.classList.remove('selected'));
      }
      setupTeamZoneClickHandler();
      updateTeamShotModeVisibility();
      updateAllPlayerShotModeVisibility();
      renderTeamZoneBreakdown(state.selectedTeamZone, getShotChartSelection('team'));
    }

    function getSortedGames() {
      return Object.values(state.games).slice().sort((a, b) => a.id.localeCompare(b.id));
    }

    function getShotChartSelection(pageKey) {
      const select = document.querySelector(`[data-role="shot-chart-select"][data-page="${pageKey}"]`);
      return select ? select.value : 'all';
    }

    function getTeamShotMode() {
      const select = document.querySelector('[data-role="team-shot-mode"]');
      if (select) {
        state.teamShotMode = select.value || state.teamShotMode;
      }
      return state.teamShotMode || 'totals';
    }

    function updateTeamShotModeVisibility() {
      const wrapper = document.querySelector('[data-role="team-shot-mode-wrapper"]');
      if (!wrapper) {
        return;
      }
      const show = getShotChartSelection('team') === 'all';
      wrapper.classList.toggle('hidden', !show);
    }

    function getPlayerShotMode(pageKey) {
      const select = document.querySelector(`[data-role="player-shot-mode"][data-page="${pageKey}"]`);
      return select ? select.value : 'totals';
    }

    function updatePlayerShotModeVisibility(pageKey) {
      const wrapper = document.querySelector(`[data-role="player-shot-mode-wrapper"][data-page="${pageKey}"]`);
      if (!wrapper) {
        return;
      }
      const show = getShotChartSelection(pageKey) === 'all';
      wrapper.classList.toggle('hidden', !show);
    }

    function updateAllPlayerShotModeVisibility() {
      roster.forEach(player => updatePlayerShotModeVisibility(String(player.number)));
    }

    function getGameCount() {
      return Object.keys(state.games).length;
    }

    function getGamesPlayedForPlayer(playerNumber) {
      const games = Object.values(state.games);
      let count = 0;
      games.forEach(game => {
        const stats = game.players[playerNumber];
        if (stats && stats.minutesSeconds > 0) {
          count += 1;
        }
      });
      return count;
    }

    function getPlayerAggregates(playerNumber) {
      const playerTotals = createEmptyStats();
      const teamTotals = createEmptyStats();
      let gamesPlayed = 0;
      let assistedMakes = 0;
      getSortedGames().forEach(game => {
        const stats = game.players[playerNumber];
        if (stats && stats.minutesSeconds > 0) {
          gamesPlayed += 1;
          addStats(playerTotals, stats);
          addStats(teamTotals, game.team);
          assistedMakes += game.assistedMakesByPlayer?.[playerNumber] || 0;
        }
      });
      return { player: playerTotals, team: teamTotals, gamesPlayed, assistedMakes };
    }

    function buildGameOptions(games, includeAll = true) {
      const options = [];
      if (includeAll) {
        options.push({ value: 'all', label: 'All Games' });
      }
      games.forEach(game => {
        const label = `${game.id} - ${game.date}`;
        options.push({ value: game.key, label });
      });
      return options;
    }

    function buildNerdOptions(games) {
      const options = [
        { value: 'all-total', label: 'All Games (Total)' },
        { value: 'all-per-game', label: 'All Games (Per Game)' }
      ];
      games.forEach(game => {
        const label = `${game.id} - ${game.date}`;
        options.push({ value: `game:${game.key}`, label });
      });
      return options;
    }

    function setSelectOptions(select, options, defaultValue) {
      select.innerHTML = '';
      options.forEach(option => {
        const opt = document.createElement('option');
        opt.value = option.value;
        opt.textContent = option.label;
        select.appendChild(opt);
      });
      if (defaultValue !== undefined) {
        select.value = defaultValue;
      } else if (options[0]) {
        select.value = options[0].value;
      }
    }

    function bindSelectOnce(select, handler) {
      if (select.dataset.bound) {
        return;
      }
      select.addEventListener('change', handler);
      select.dataset.bound = 'true';
    }

    function renderPlayerTables() {
      const games = getSortedGames();

      roster.forEach(player => {
        const gamesPlayed = getGamesPlayedForPlayer(player.number);
        const table = document.querySelector(`[data-role="player-log"][data-page="${player.number}"]`);
        if (!table) {
          return;
        }
        const thead = table.querySelector('thead');
        const tbody = table.querySelector('tbody');
        const tfoot = table.querySelector('tfoot');

        thead.innerHTML = buildStatHeaderHtml('Game', true);
        tbody.innerHTML = '';
        tfoot.innerHTML = '';

        games.forEach(game => {
          const stats = game.players[player.number] || createEmptyStats();
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${game.id}</td>
            <td>${game.date}</td>
            ${buildStatCells(stats, { isAverage: false })}
          `;
          tbody.appendChild(row);
        });

        const totals = state.overall.players[player.number];
        tfoot.appendChild(buildFooterRow('Totals', totals, true, false));
        tfoot.appendChild(buildFooterRow('Averages', totals, true, true, gamesPlayed));
      });
    }

    function renderPlayerAdvancedTables() {
      const games = getSortedGames();

      roster.forEach(player => {
        const table = document.querySelector(`[data-role="player-advanced"][data-page="${player.number}"]`);
        if (!table) {
          return;
        }

        const aggregates = getPlayerAggregates(player.number);
        const thead = table.querySelector('thead');
        const tbody = table.querySelector('tbody');
        const tfoot = table.querySelector('tfoot');

        thead.innerHTML = buildAdvancedHeaderHtml('Game', true);
        tbody.innerHTML = '';
        tfoot.innerHTML = '';

        games.forEach(game => {
          const stats = game.players[player.number] || createEmptyStats();
          const assistedMakes = game.assistedMakesByPlayer?.[player.number] || 0;
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${game.id}</td>
            <td>${game.date}</td>
            ${buildAdvancedCells(stats, game.team, { isAverage: false, averageDivisor: 0, assistedMakes })}
          `;
          tbody.appendChild(row);
        });

        tfoot.appendChild(buildAdvancedFooterRow('Totals', aggregates.player, aggregates.team, true, false, 0, aggregates.assistedMakes));
        tfoot.appendChild(buildAdvancedFooterRow('Averages', aggregates.player, aggregates.team, true, true, aggregates.gamesPlayed, aggregates.assistedMakes));
      });
    }

    function renderTeamTable() {
      const table = document.querySelector('[data-role="team-table"]');
      const title = document.querySelector('[data-role="team-table-title"]');
      const viewSelect = document.querySelector('[data-role="team-view"]');
      if (!table || !viewSelect || !title) {
        return;
      }

      const view = viewSelect.value || 'averages';
      const games = getSortedGames();
      const gameCount = getGameCount();
      const thead = table.querySelector('thead');
      const tbody = table.querySelector('tbody');
      const tfoot = table.querySelector('tfoot');

      tbody.innerHTML = '';
      tfoot.innerHTML = '';

      if (view === 'team-game') {
        title.textContent = 'Team Game Log';
        thead.innerHTML = buildStatHeaderHtml('Game', true);

        games.forEach(game => {
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${game.id}</td>
            <td>${game.date}</td>
            ${buildStatCells(game.team, { isAverage: false })}
          `;
          tbody.appendChild(row);
        });

        const totals = state.overall.team;
        tfoot.appendChild(buildFooterRow('Team Totals', totals, true, false));
        tfoot.appendChild(buildFooterRow('Team Averages', totals, true, true, gameCount));
      } else {
        const isAverageView = view === 'averages';
        title.textContent = isAverageView ? 'Player Averages' : 'Player Totals';
        thead.innerHTML = buildStatHeaderHtml('Player', false, true, true, true);

        roster.forEach(player => {
          const stats = state.overall.players[player.number];
          const gamesPlayed = getGamesPlayedForPlayer(player.number);
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${player.number}</td>
            <td>${player.name}</td>
            <td>${gamesPlayed}</td>
            ${buildStatCells(stats, { isAverage: isAverageView, averageDivisor: isAverageView ? gamesPlayed : 0 })}
          `;
          tbody.appendChild(row);
        });

        const teamLabel = isAverageView ? 'Team Averages' : 'Team Totals';
        tfoot.appendChild(buildFooterRowWithGp(teamLabel, gameCount, state.overall.team, isAverageView, isAverageView ? gameCount : 0, true, true));
      }
    }

    function renderTeamBoxScore() {
      const table = document.querySelector('[data-role="team-boxscore"]');
      const select = document.querySelector('[data-role="team-box-select"]');
      if (!table || !select) {
        return;
      }

      const games = getSortedGames();
      const thead = table.querySelector('thead');
      const tbody = table.querySelector('tbody');
      const tfoot = table.querySelector('tfoot');

      thead.innerHTML = buildStatHeaderHtml('Player', false, false, true, true);
      tbody.innerHTML = '';
      tfoot.innerHTML = '';

      if (!games.length) {
        return;
      }

      if (!select.value) {
        select.value = games[0].key;
      }

      const game = games.find(item => item.key === select.value) || games[0];
      roster.forEach(player => {
        const stats = game.players[player.number] || createEmptyStats();
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${player.number}</td>
          <td>${player.name}</td>
          ${buildStatCells(stats, { isAverage: false })}
        `;
        tbody.appendChild(row);
      });

      tfoot.appendChild(buildFooterRowWithNumber('Team Totals', game.team, false, false));
      renderTeamActionLog(game);
    }

    function renderTeamActionLog(game) {
      const logTable = document.querySelector('[data-role="team-action-log"] tbody');
      if (!logTable) {
        return;
      }
      logTable.innerHTML = '';
      const entries = Array.isArray(game?.actionLog) ? game.actionLog : [];
      if (!entries.length) {
        const row = document.createElement('tr');
        row.innerHTML = '<td>No action log entries found.</td>';
        logTable.appendChild(row);
        return;
      }
      entries.forEach(entry => {
        const row = document.createElement('tr');
        row.innerHTML = `<td>${entry}</td>`;
        logTable.appendChild(row);
      });
    }

    function buildAssistEdges() {
      const totals = {};
      const matrix = {};
      const rosterNumbers = new Set(roster.map(player => player.number));

      const selection = state.nerdSelection || 'all-total';
      const games = getSortedGames();
      let selectedGames = games;
      let isAverage = false;
      let factor = 1;

      if (selection.startsWith('game:')) {
        const key = selection.replace('game:', '');
        const game = state.games[key];
        selectedGames = game ? [game] : [];
      } else if (selection === 'all-per-game') {
        isAverage = true;
        const count = games.length || 0;
        factor = count ? 1 / count : 0;
      }

      selectedGames.forEach(game => {
        const pairs = game.assistPairs || {};
        Object.keys(pairs).forEach(from => {
          const fromNumber = Number.parseInt(from, 10);
          if (!rosterNumbers.has(fromNumber)) {
            return;
          }
          const targets = pairs[from] || {};
          Object.keys(targets).forEach(to => {
            const toNumber = Number.parseInt(to, 10);
            if (!rosterNumbers.has(toNumber)) {
              return;
            }
            if (fromNumber === toNumber) {
              return;
            }
            const count = targets[to] || 0;
            if (!count) {
              return;
            }
            const key = `${fromNumber}-${toNumber}`;
            totals[key] = (totals[key] || 0) + count;
            if (!matrix[fromNumber]) {
              matrix[fromNumber] = {};
            }
            matrix[fromNumber][toNumber] = (matrix[fromNumber][toNumber] || 0) + count;
          });
        });
      });

      if (isAverage && factor > 0) {
        Object.keys(totals).forEach(key => {
          totals[key] *= factor;
        });
        Object.keys(matrix).forEach(from => {
          Object.keys(matrix[from]).forEach(to => {
            matrix[from][to] *= factor;
          });
        });
      }

      const edges = [];
      let min = Infinity;
      let max = 0;

      Object.entries(totals).forEach(([key, count]) => {
        if (!count) {
          return;
        }
        const [from, to] = key.split('-').map(value => Number.parseInt(value, 10));
        if (!Number.isFinite(from) || !Number.isFinite(to)) {
          return;
        }
        min = Math.min(min, count);
        max = Math.max(max, count);
        edges.push({ from, to, count });
      });

      state.nerdMatrix = matrix;
      state.nerdIsAverage = isAverage;

      if (!edges.length) {
        return { edges: [] };
      }

      const minWidth = 1.5;
      const maxWidth = minWidth * 4;
      const minAlpha = 0.25;
      const maxAlpha = 0.95;
      const spread = max > min ? max - min : 1;

      edges.forEach(edge => {
        const t = max > min ? (edge.count - min) / spread : 1;
        edge.width = minWidth + t * (maxWidth - minWidth);
        edge.alpha = minAlpha + t * (maxAlpha - minAlpha);
      });

      return { edges };
    }

    function renderNerdZone() {
      const svg = document.querySelector('[data-role="nerdzone-svg"]');
      if (!svg) {
        return;
      }
      const empty = document.querySelector('[data-role="nerdzone-empty"]');

      svg.innerHTML = '';
      state.nerdHover = null;

      const { edges } = buildAssistEdges();
      if (empty) {
        empty.classList.toggle('hidden', edges.length > 0);
      }

      const svgWidth = 600;
      const svgHeight = 320;
      const center = { x: svgWidth / 2, y: svgHeight / 2 };
      const radius = Math.max(100, Math.min(center.x - 80, center.y - 40));
      const positions = {};
      const totalPlayers = roster.length || 1;

      roster.forEach((player, index) => {
        const angle = (Math.PI * 2 * index) / totalPlayers - Math.PI / 2;
        positions[player.number] = {
          x: center.x + radius * Math.cos(angle),
          y: center.y + radius * Math.sin(angle)
        };
      });

      const svgNS = 'http://www.w3.org/2000/svg';
      const nodeRadius = 16;

      const defs = document.createElementNS(svgNS, 'defs');
      const greenMarker = document.createElementNS(svgNS, 'marker');
      greenMarker.setAttribute('id', 'nerd-arrow-green');
      greenMarker.setAttribute('markerWidth', '8');
      greenMarker.setAttribute('markerHeight', '8');
      greenMarker.setAttribute('refX', '6');
      greenMarker.setAttribute('refY', '3');
      greenMarker.setAttribute('orient', 'auto');
      greenMarker.setAttribute('markerUnits', 'strokeWidth');
      const greenArrow = document.createElementNS(svgNS, 'path');
      greenArrow.setAttribute('d', 'M0,0 L6,3 L0,6 Z');
      greenArrow.setAttribute('fill', '#16a34a');
      greenMarker.appendChild(greenArrow);
      defs.appendChild(greenMarker);

      const redMarker = document.createElementNS(svgNS, 'marker');
      redMarker.setAttribute('id', 'nerd-arrow-blue');
      redMarker.setAttribute('markerWidth', '8');
      redMarker.setAttribute('markerHeight', '8');
      redMarker.setAttribute('refX', '6');
      redMarker.setAttribute('refY', '3');
      redMarker.setAttribute('orient', 'auto');
      redMarker.setAttribute('markerUnits', 'strokeWidth');
      const redArrow = document.createElementNS(svgNS, 'path');
      redArrow.setAttribute('d', 'M0,0 L6,3 L0,6 Z');
      redArrow.setAttribute('fill', '#2563eb');
      redMarker.appendChild(redArrow);
      defs.appendChild(redMarker);

      const grayMarker = document.createElementNS(svgNS, 'marker');
      grayMarker.setAttribute('id', 'nerd-arrow-gray');
      grayMarker.setAttribute('markerWidth', '8');
      grayMarker.setAttribute('markerHeight', '8');
      grayMarker.setAttribute('refX', '6');
      grayMarker.setAttribute('refY', '3');
      grayMarker.setAttribute('orient', 'auto');
      grayMarker.setAttribute('markerUnits', 'strokeWidth');
      const grayArrow = document.createElementNS(svgNS, 'path');
      grayArrow.setAttribute('d', 'M0,0 L6,3 L0,6 Z');
      grayArrow.setAttribute('fill', '#94a3b8');
      grayMarker.appendChild(grayArrow);
      defs.appendChild(grayMarker);

      svg.appendChild(defs);

      const pairMap = new Map();
      edges.forEach(edge => {
        const key = edge.from < edge.to ? `${edge.from}-${edge.to}` : `${edge.to}-${edge.from}`;
        const entry = pairMap.get(key) || { a: null, b: null };
        if (edge.from < edge.to) {
          entry.a = edge;
        } else {
          entry.b = edge;
        }
        pairMap.set(key, entry);
      });

      pairMap.forEach((pair, key) => {
        const [leftKey, rightKey] = key.split('-').map(value => Number.parseInt(value, 10));
        const leftPos = positions[leftKey];
        const rightPos = positions[rightKey];
        if (!leftPos || !rightPos) {
          return;
        }

        const dx = rightPos.x - leftPos.x;
        const dy = rightPos.y - leftPos.y;
        const len = Math.hypot(dx, dy) || 1;
        const unitX = dx / len;
        const unitY = dy / len;
        const perpX = -unitY;
        const perpY = unitX;

        const leftOffsetX = unitX * nodeRadius;
        const leftOffsetY = unitY * nodeRadius;

        const greenEdge = pair.a;
        const redEdge = pair.b;
        const greenWidth = greenEdge ? greenEdge.width : 0;
        const redWidth = redEdge ? redEdge.width : 0;
        const offsetDistance = greenWidth && redWidth ? ((greenWidth + redWidth) * 0.25 + 0.5) : 0;

        if (greenEdge) {
          const line = document.createElementNS(svgNS, 'line');
          line.classList.add('nerd-edge');
          line.setAttribute('x1', leftPos.x + leftOffsetX + perpX * offsetDistance);
          line.setAttribute('y1', leftPos.y + leftOffsetY + perpY * offsetDistance);
          line.setAttribute('x2', rightPos.x - leftOffsetX + perpX * offsetDistance);
          line.setAttribute('y2', rightPos.y - leftOffsetY + perpY * offsetDistance);
          line.dataset.from = String(greenEdge.from);
          line.dataset.to = String(greenEdge.to);
          line.dataset.count = String(greenEdge.count);
          line.dataset.alpha = greenEdge.alpha.toFixed(2);
          line.dataset.color = 'green';
          line.style.stroke = '#16a34a';
          line.style.strokeWidth = greenEdge.width.toFixed(2);
          line.style.opacity = greenEdge.alpha.toFixed(2);
          line.setAttribute('marker-end', 'url(#nerd-arrow-green)');
          svg.appendChild(line);
        }

        if (redEdge) {
          const line = document.createElementNS(svgNS, 'line');
          line.classList.add('nerd-edge');
          line.setAttribute('x1', rightPos.x - leftOffsetX - perpX * offsetDistance);
          line.setAttribute('y1', rightPos.y - leftOffsetY - perpY * offsetDistance);
          line.setAttribute('x2', leftPos.x + leftOffsetX - perpX * offsetDistance);
          line.setAttribute('y2', leftPos.y + leftOffsetY - perpY * offsetDistance);
          line.dataset.from = String(redEdge.from);
          line.dataset.to = String(redEdge.to);
          line.dataset.count = String(redEdge.count);
          line.dataset.alpha = redEdge.alpha.toFixed(2);
          line.dataset.color = 'blue';
          line.style.stroke = '#2563eb';
          line.style.strokeWidth = redEdge.width.toFixed(2);
          line.style.opacity = redEdge.alpha.toFixed(2);
          line.setAttribute('marker-end', 'url(#nerd-arrow-blue)');
          svg.appendChild(line);
        }
      });

      roster.forEach(player => {
        const pos = positions[player.number];
        if (!pos) {
          return;
        }
        const group = document.createElementNS(svgNS, 'g');
        group.classList.add('nerd-node');
        group.dataset.player = String(player.number);
        group.setAttribute('transform', `translate(${pos.x}, ${pos.y})`);

        const circle = document.createElementNS(svgNS, 'circle');
        circle.setAttribute('r', String(nodeRadius));
        circle.setAttribute('cx', '0');
        circle.setAttribute('cy', '0');

        const text = document.createElementNS(svgNS, 'text');
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('dominant-baseline', 'middle');
        text.textContent = player.name;

        group.appendChild(circle);
        group.appendChild(text);
        group.addEventListener('mouseenter', () => {
          state.nerdHover = player.number;
          updateNerdEdges(svg);
        });
        group.addEventListener('mouseleave', () => {
          state.nerdHover = null;
          updateNerdEdges(svg);
        });

        svg.appendChild(group);
      });

      updateNerdEdges(svg);
      renderNerdBreakdown(null);
    }

    function updateNerdEdges(svg) {
      if (!svg) {
        return;
      }
      const active = state.nerdHover;
      const edges = svg.querySelectorAll('.nerd-edge');
      edges.forEach(edge => {
        const from = edge.dataset.from;
        const to = edge.dataset.to;
        const show = !active || from === String(active) || to === String(active);
        edge.style.opacity = show ? (edge.dataset.alpha || '1') : '0';

        if (active) {
          if (from === String(active)) {
            edge.style.stroke = '#16a34a';
            edge.setAttribute('marker-end', 'url(#nerd-arrow-green)');
          } else if (to === String(active)) {
            edge.style.stroke = '#2563eb';
            edge.setAttribute('marker-end', 'url(#nerd-arrow-blue)');
          }
          return;
        }

        edge.style.stroke = '#94a3b8';
        edge.setAttribute('marker-end', 'url(#nerd-arrow-gray)');
      });
      const nodes = svg.querySelectorAll('.nerd-node');
      nodes.forEach(node => {
        node.classList.toggle('active', active && node.dataset.player === String(active));
      });
      renderNerdBreakdown(active);
    }

    function renderNerdBreakdown(activePlayer) {
      const title = document.querySelector('[data-role="nerd-breakdown-title"]');
      const tbody = document.querySelector('[data-role="nerd-breakdown-table"] tbody');
      if (!title || !tbody) {
        return;
      }
      tbody.innerHTML = '';
      if (!activePlayer) {
        title.textContent = 'Hover a player to see assist breakdown';
        return;
      }

      const player = roster.find(item => item.number === activePlayer);
      title.textContent = player ? `${player.name} assist breakdown` : 'Assist breakdown';

      let hasRows = false;
      roster.forEach(other => {
        if (other.number === activePlayer) {
          return;
        }
        const given = state.nerdMatrix?.[activePlayer]?.[other.number] || 0;
        const received = state.nerdMatrix?.[other.number]?.[activePlayer] || 0;
        if (!given && !received) {
          return;
        }
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${other.name}</td>
          <td>${formatNumber(given, state.nerdIsAverage)}</td>
          <td>${formatNumber(received, state.nerdIsAverage)}</td>
        `;
        tbody.appendChild(row);
        hasRows = true;
      });

      if (!hasRows) {
        const row = document.createElement('tr');
        row.innerHTML = '<td colspan="3">No assists recorded.</td>';
        tbody.appendChild(row);
      }
    }

    function renderAllShotCharts() {
      document.querySelectorAll('[data-role="shot-chart-select"]').forEach(select => {
        const pageKey = select.dataset.page;
        const value = select.value || 'all';
        renderShotChartForPage(pageKey, value);
      });
    }

    function setupTeamZoneClickHandler() {
      const container = document.querySelector('[data-role="shot-chart"][data-page="team"]');
      if (!container || container.dataset.bound) {
        return;
      }
      container.addEventListener('click', (event) => {
        const zoneBox = event.target.closest('.chart-zone');
        if (!zoneBox) {
          return;
        }
        const zoneKey = zoneBox.dataset.zone;
        if (!zoneKey) {
          return;
        }
        state.selectedTeamZone = zoneKey;
        container.querySelectorAll('.chart-zone').forEach(box => {
          box.classList.toggle('selected', box === zoneBox);
        });
        renderTeamZoneBreakdown(zoneKey, getShotChartSelection('team'));
      });
      container.dataset.bound = 'true';
    }

    function renderTeamZoneBreakdown(zoneKey, gameKey) {
      const breakdown = document.querySelector('[data-role="zone-breakdown"]');
      if (!breakdown) {
        return;
      }
      const title = breakdown.querySelector('[data-role="zone-breakdown-title"]');
      const tbody = breakdown.querySelector('tbody');
      if (!tbody || !title) {
        return;
      }

      tbody.innerHTML = '';
      if (!zoneKey) {
        title.textContent = 'Click a zone to see player splits';
        return;
      }

      const label = zoneLabels[zoneKey] || zoneKey;
      const isAverageMode = gameKey === 'all' && getTeamShotMode() === 'averages';
      const modeLabel = gameKey === 'all'
        ? (isAverageMode ? 'All Games (Avg)' : 'All Games')
        : 'Selected Game';
      title.textContent = `${label} splits (${modeLabel})`;

      let hasRows = false;
      roster.forEach(player => {
        const stats = getStatsFor(String(player.number), gameKey);
        const zone = stats?.zones?.[zoneKey] || { make: 0, miss: 0 };
        const divisor = isAverageMode ? getGamesPlayedForPlayer(player.number) : 1;
        const factor = isAverageMode ? (divisor ? 1 / divisor : 0) : 1;
        const makes = (zone.make || 0) * factor;
        const attempts = ((zone.make || 0) + (zone.miss || 0)) * factor;
        if (!attempts) {
          return;
        }
        const pct = attempts ? `${((zone.make / (zone.make + zone.miss)) * 100).toFixed(1)}%` : '--%';

        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${player.number}</td>
          <td>${player.name}</td>
          <td>${formatShotValue(makes, isAverageMode)}</td>
          <td>${formatShotValue(attempts, isAverageMode)}</td>
          <td>${pct}</td>
        `;
        tbody.appendChild(row);
        hasRows = true;
      });

      if (!hasRows) {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td colspan="5">No attempts recorded.</td>
        `;
        tbody.appendChild(row);
      }
    }

    function renderShotChartForPage(pageKey, gameKey) {
      const chartContainer = document.querySelector(`[data-role="shot-chart"][data-page="${pageKey}"]`);
      if (!chartContainer) {
        return;
      }
      const { stats, isAverage } = getShotChartStats(pageKey, gameKey);
      updateShotChart(chartContainer, stats, { isAverage });
    }

    function getStatsFor(pageKey, gameKey) {
      if (gameKey === 'all') {
        return pageKey === 'team' ? state.overall.team : state.overall.players[pageKey];
      }

      const game = state.games[gameKey];
      if (!game) {
        return pageKey === 'team' ? state.overall.team : state.overall.players[pageKey];
      }
      return pageKey === 'team' ? game.team : game.players[pageKey];
    }

    function getShotChartStats(pageKey, gameKey) {
      const baseStats = getStatsFor(pageKey, gameKey);
      if (gameKey !== 'all') {
        return { stats: baseStats, isAverage: false };
      }

      if (pageKey === 'team') {
        const mode = getTeamShotMode();
        if (mode !== 'averages') {
          return { stats: baseStats, isAverage: false };
        }

        const gameCount = getGameCount();
        if (!gameCount) {
          return { stats: baseStats, isAverage: false };
        }

        return { stats: scaleShotChartStats(baseStats, 1 / gameCount), isAverage: true };
      }

      const mode = getPlayerShotMode(pageKey);
      if (mode !== 'averages') {
        return { stats: baseStats, isAverage: false };
      }

      const playerNumber = parseInt(pageKey, 10);
      if (!Number.isFinite(playerNumber)) {
        return { stats: baseStats, isAverage: false };
      }
      const gamesPlayed = getGamesPlayedForPlayer(playerNumber);
      if (!gamesPlayed) {
        return { stats: baseStats, isAverage: false };
      }

      return { stats: scaleShotChartStats(baseStats, 1 / gamesPlayed), isAverage: true };
    }

    function scaleShotChartStats(stats, factor) {
      const scaled = createEmptyStats();
      zoneKeys.forEach(zone => {
        scaled.zones[zone].make = (stats.zones[zone]?.make || 0) * factor;
        scaled.zones[zone].miss = (stats.zones[zone]?.miss || 0) * factor;
      });
      return scaled;
    }

    function buildStatHeaderHtml(firstLabel, includeDate, includeGp = false, includeNumber = false, numberFirst = false) {
      const dateHeader = includeDate ? '<th>Date</th>' : '';
      const gpHeader = includeGp ? '<th>GP</th>' : '';
      const labelCells = includeNumber && numberFirst
        ? `<th>No.</th><th>${firstLabel}</th>`
        : `<th>${firstLabel}</th>${includeNumber ? '<th>No.</th>' : ''}`;
      return `
        <tr>
          ${labelCells}
          ${dateHeader}
          ${gpHeader}
          ${statHeaderHtml}
        </tr>
      `;
    }

    function buildAdvancedHeaderHtml(firstLabel, includeDate) {
      const dateHeader = includeDate ? '<th>Date</th>' : '';
      return `
        <tr>
          <th>${firstLabel}</th>
          ${dateHeader}
          ${advancedHeaderHtml}
        </tr>
      `;
    }

    function buildStatCells(stats, options) {
      const isAverage = options.isAverage;
      const divisor = options.averageDivisor || 0;
      const factor = isAverage ? (divisor ? 1 / divisor : 0) : 1;
      const derived = buildDerived(stats);

      const minutes = stats.minutesSeconds * factor;
      const offReb = stats.offReb * factor;
      const defReb = stats.defReb * factor;
      const reb = (stats.offReb + stats.defReb) * factor;
      const ast = stats.ast * factor;
      const stl = stats.stl * factor;
      const blk = stats.blk * factor;
      const tov = stats.tov * factor;
      const foulCommitted = stats.foulCommitted * factor;
      const points = derived.points * factor;

      const fgMakes = derived.fgMakes * factor;
      const fgAttempts = derived.fgAttempts * factor;
      const threeMakes = derived.threeMakes * factor;
      const threeAttempts = derived.threeAttempts * factor;
      const ftMakes = derived.ftMakes * factor;
      const ftAttempts = derived.ftAttempts * factor;

      return `
        <td>${formatDuration(minutes)}</td>
        <td>${formatNumber(points, isAverage)}</td>
        <td>${formatNumber(fgMakes, isAverage)}</td>
        <td>${formatNumber(fgAttempts, isAverage)}</td>
        <td>${formatPercentValue(fgMakes, fgAttempts)}</td>
        <td>${formatNumber(threeMakes, isAverage)}</td>
        <td>${formatNumber(threeAttempts, isAverage)}</td>
        <td>${formatPercentValue(threeMakes, threeAttempts)}</td>
        <td>${formatNumber(ftMakes, isAverage)}</td>
        <td>${formatNumber(ftAttempts, isAverage)}</td>
        <td>${formatPercentValue(ftMakes, ftAttempts)}</td>
        <td>${formatNumber(offReb, isAverage)}</td>
        <td>${formatNumber(defReb, isAverage)}</td>
        <td>${formatNumber(reb, isAverage)}</td>
        <td>${formatNumber(ast, isAverage)}</td>
        <td>${formatNumber(stl, isAverage)}</td>
        <td>${formatNumber(blk, isAverage)}</td>
        <td>${formatNumber(tov, isAverage)}</td>
        <td>${formatNumber(foulCommitted, isAverage)}</td>
      `;
    }

    function buildAdvancedCells(stats, teamStats, options) {
      const isAverage = options.isAverage;
      const divisor = options.averageDivisor || 0;
      const factor = isAverage ? (divisor ? 1 / divisor : 0) : 1;
      const assistedMakes = (options.assistedMakes || 0) * factor;
      const derived = buildDerived(stats);
      const teamDerived = buildDerived(teamStats || createEmptyStats());

      const minutes = stats.minutesSeconds * factor;
      const ast = stats.ast * factor;
      const potAst = stats.potAst * factor;
      const stl = stats.stl * factor;
      const blk = stats.blk * factor;
      const blkAgainst = stats.blkAgainst * factor;
      const tov = stats.tov * factor;
      const foulCommitted = stats.foulCommitted * factor;
      const foulDrawn = stats.foulCalled * factor;
      const points = derived.points * factor;

      const fgMakes = derived.fgMakes * factor;
      const fgAttempts = derived.fgAttempts * factor;
      const threeMakes = derived.threeMakes * factor;
      const ftMakes = derived.ftMakes * factor;
      const ftAttempts = derived.ftAttempts * factor;

      const fgAstPct = fgMakes ? (assistedMakes / fgMakes) * 100 : null;
      const efg = fgAttempts ? (fgMakes + 0.5 * threeMakes) / fgAttempts : null;
      const tsDenom = (2 * fgAttempts) + (0.44 * ftAttempts);
      const ts = tsDenom ? points / tsDenom : null;
      const gmsc = points
        + 0.4 * fgMakes
        - 0.7 * fgAttempts
        - 0.4 * (ftAttempts - ftMakes)
        + 0.7 * (stats.offReb * factor)
        + 0.3 * (stats.defReb * factor)
        + stl
        + 0.7 * ast
        + 0.7 * blk
        - 0.4 * foulCommitted
        - tov;

      const teamMinutes = (teamStats?.minutesSeconds || 0) * factor / 60;
      const playerMinutes = minutes / 60;
      const teamFg = teamDerived.fgMakes * factor;
      let astPct = null;
      if (teamMinutes > 0 && teamFg > 0 && playerMinutes > 0) {
        const denom = ((playerMinutes / (teamMinutes / 5)) * teamFg) - fgMakes;
        if (denom > 0) {
          astPct = (ast / denom) * 100;
        }
      }

      let usgPct = null;
      const teamFga = teamDerived.fgAttempts * factor;
      const teamFta = teamDerived.ftAttempts * factor;
      const teamTov = (teamStats?.tov || 0) * factor;
      const playerFga = fgAttempts;
      const playerFta = ftAttempts;
      const playerTov = tov;
      if (playerMinutes > 0 && teamMinutes > 0) {
        const denom = playerMinutes * (teamFga + 0.44 * teamFta + teamTov);
        if (denom > 0) {
          usgPct = 100 * ((playerFga + 0.44 * playerFta + playerTov) * (teamMinutes / 5)) / denom;
        }
      }

      return `
        <td>${formatNumber(potAst, isAverage)}</td>
        <td>${formatRate(astPct, true)}</td>
        <td>${formatNumber(blkAgainst, isAverage)}</td>
        <td>${formatNumber(foulDrawn, isAverage)}</td>
        <td>${formatRate(fgAstPct, true)}</td>
        <td>${formatRate(ts)}</td>
        <td>${formatRate(efg)}</td>
        <td>${formatRate(usgPct, true)}</td>
        <td>${formatNumber(gmsc, true)}</td>
      `;
    }

    function buildAdvancedFooterRow(label, stats, teamStats, includeDate, isAverage, averageDivisor = 0, assistedMakes = 0) {
      const row = document.createElement('tr');
      row.className = isAverage ? 'averages-row' : 'totals-row';
      const leadCells = includeDate ? `<td>${label}</td><td></td>` : `<td>${label}</td>`;
      row.innerHTML = `${leadCells}${buildAdvancedCells(stats, teamStats, { isAverage, averageDivisor, assistedMakes })}`;
      return row;
    }

    function formatRate(value, alreadyPercent = false) {
      if (value === null || value === undefined || Number.isNaN(value)) {
        return '--%';
      }
      const scaled = alreadyPercent ? value : value * 100;
      return `${scaled.toFixed(1)}%`;
    }

    function buildFooterRow(label, stats, includeDate, isAverage, averageDivisor = 0) {
      const row = document.createElement('tr');
      row.className = isAverage ? 'averages-row' : 'totals-row';
      const leadCells = includeDate ? `<td>${label}</td><td></td>` : `<td>${label}</td>`;
      row.innerHTML = `${leadCells}${buildStatCells(stats, { isAverage, averageDivisor })}`;
      return row;
    }

    function buildFooterRowWithGp(label, gpValue, stats, isAverage, averageDivisor = 0, includeNumber = false, numberFirst = false) {
      const row = document.createElement('tr');
      row.className = isAverage ? 'averages-row' : 'totals-row';
      const numberCell = includeNumber ? '<td></td>' : '';
      const leadingCells = numberFirst
        ? `${numberCell}<td>${label}</td>`
        : `<td>${label}</td>${numberCell}`;
      row.innerHTML = `
        ${leadingCells}
        <td>${gpValue ?? ''}</td>
        ${buildStatCells(stats, { isAverage, averageDivisor })}
      `;
      return row;
    }

    function buildFooterRowWithNumber(label, stats, includeDate, isAverage, averageDivisor = 0, numberFirst = true) {
      const row = document.createElement('tr');
      row.className = isAverage ? 'averages-row' : 'totals-row';
      const numberCell = '<td></td>';
      const labelCell = `<td>${label}</td>`;
      const dateCell = includeDate ? '<td></td>' : '';
      const leadingCells = numberFirst ? `${numberCell}${labelCell}` : `${labelCell}${numberCell}`;
      row.innerHTML = `
        ${leadingCells}
        ${dateCell}
        ${buildStatCells(stats, { isAverage, averageDivisor })}
      `;
      return row;
    }

    function formatNumber(value, isAverage) {
      const safe = Number.isFinite(value) ? value : 0;
      if (isAverage) {
        return safe.toFixed(1);
      }
      return Math.round(safe).toString();
    }

    function formatMakeAttempts(makes, attempts, isAverage) {
      if (isAverage) {
        return `${formatDecimal(makes)}-${formatDecimal(attempts)}`;
      }
      return `${Math.round(makes)}-${Math.round(attempts)}`;
    }

    function formatPercentValue(makes, attempts) {
      if (!attempts) {
        return '--%';
      }
      return `${((makes / attempts) * 100).toFixed(1)}%`;
    }

    function formatDecimal(value) {
      const safe = Number.isFinite(value) ? value : 0;
      return safe.toFixed(1);
    }

    function updateShotChart(container, stats, options = {}) {
      if (!container) {
        return;
      }
      const isAverage = options.isAverage === true;

      zoneKeys.forEach(zone => {
        const data = stats.zones[zone];
        const attempts = data.make + data.miss;
        const pct = attempts ? data.make / attempts : null;
        const box = container.querySelector(`[data-zone="${zone}"]`);
        const text = container.querySelector(`[data-zone-text="${zone}"]`);

        if (box) {
          box.style.backgroundColor = getZoneColorForZone(zone, pct, attempts);
        }
        if (text) {
          const pctText = attempts ? `${Math.round(pct * 100)}%` : '--%';
          const makeText = formatShotValue(data.make, isAverage);
          const attemptText = formatShotValue(attempts, isAverage);
          text.textContent = `${makeText}/${attemptText} (${pctText})`;
        }
      });
    }

    function formatShotValue(value, isAverage) {
      const safe = Number.isFinite(value) ? value : 0;
      return isAverage ? safe.toFixed(1) : Math.round(safe).toString();
    }

    function hexToRgb(hex) {
      const sanitized = hex.replace('#', '');
      const value = parseInt(sanitized, 16);
      return {
        r: (value >> 16) & 255,
        g: (value >> 8) & 255,
        b: value & 255
      };
    }

    function interpolateColor(startHex, endHex, t) {
      const start = hexToRgb(startHex);
      const end = hexToRgb(endHex);

      const r = Math.round(start.r + (end.r - start.r) * t);
      const g = Math.round(start.g + (end.g - start.g) * t);
      const b = Math.round(start.b + (end.b - start.b) * t);

      return `rgb(${r}, ${g}, ${b})`;
    }

    function getZoneColorForZone(zone, pct, attempts) {
      if (!attempts) {
        return '#e2e8f0';
      }
      const category = zoneCategoryLookup[zone] || 'midRange';
      const expected = zoneAverages[category] ?? 0.4;
      const spread = zoneRange || 0.2;
      const maxAttempts = maxAttemptsForIntensity || 10;

      const intensity = Math.min(attempts / maxAttempts, 1);
      const diff = pct === null ? 0 : pct - expected;
      const normalized = Math.max(-1, Math.min(1, diff / spread));

      const hue = 60 + normalized * 60;
      const targetSaturation = 70;
      const targetLightness = 55;
      const saturation = 5 + intensity * (targetSaturation - 5);
      const lightness = 96 - intensity * (96 - targetLightness);

      return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

  </script>
</body>
</html>
